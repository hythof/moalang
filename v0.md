# Draft specification

This is subset specification for first generation runtime

## 1. Value

Literals
```
true       # bool
1          # int 64bit signed integer
"hi"       # string utf8
1,2        # tuple
a,b => a+b # lambda
```

Containers
```
[1 2 3] # list: [1 2 3](1) == 2
1,2     # tuple: (1,2)(0) == 1
```

Type
```
person: name string, age int
person("moa" 1).age == 1

ast:| int int, op2: op string, lhs string, rhs string
eval n = ast(n
  v => v
  o => case(o.op
    "+" eval(o.lhs) + eval(o.rhs)
    "-" eval(o.lhs) + eval(o.rhs)))
```



## 2. Definition

```
pi = 3.14
add = a,b => a + b
```



## 3. Expression

Binary operation
```
+ - * /         # math
> >= < <= == != # comparing
|| &&           # bool operations
:= += -= *= /=  # update variable
<-              # effect
```

Branch
```
if(n==0 "zero" "many")
case(n
  0 "zero"
  1 "one"
  _ "many")
```

Effect
```
do(
  n := 0
  n+=1
  inc = n+=2
  inc
  n) # == 3
```



## 4. Syntax
```
root: def (br def)*
def:
| id = exp
exp:
| id eff unit
| unit (op2 exp)?
unit: node ("(" exp+ ")" | "." id)*
node:
| "(" exp ")"
| '"' [^"]* '"'
| [0-9]+
| id (("," id)* "=>" exp)?
id: [a-z0-9_]+
op2: [. + - * / > < >= <= == != || &&]
eff: [:= += *= /=]
```



## 4. Example
```
token: tag string, val string
miss = error("miss")
tokenize = src => do(
  pos := 0
  tokens := []
  top

  top = do(
    t <- read_num.catch(miss read_op)
    tokens.append(t)
    top.catch(miss tokens))
  read_op = any("+ - * /".split(" "))
  read_num = do(
    s <- many1(any("0123456789".list))
    token("num" s.join("").int))
  many1 = f => do(
    c <- f
    cs <- many(f)
    [c] ++ cs)
  many = f => _many(f [])
  _many = f,acc => do(
    c <- f
    _many(f [c] ++ acc).catch(miss acc)
  any = ary => ary.first(satisfy)
  satisfy = f => do(
    skip
    skip = if((c==" " || c=="\n") do(pos+=1; skip) try)
    c = src.char(pos)
    try = if(f(c) do(pos+=1; c) nil)))
```



## 5. Buildin
any
- string: string
nil
bool
int
string
- slice: int -> int -> string
- sub: string -> string -> string
- int: opt(int)
- trim: string
list a
- size: int
- nth: int -> opt(a)
- slice: int -> int -> string
- map b: (a -> b) -> list(a)
- keep: (a -> bool) -> list(a)
error: class(message:string)
try a | opt(a) | error
- then b: (a -> b) try(b)
- catch b: (error -> b) b
- or: a try(a)
- and: a try(a)
