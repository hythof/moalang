# Draft specification

This is subset specification for first generation runtime

## 1. Value

Literals
```
true       # bool
1          # int 64bit signed integer
"hi"       # string utf8
1,2        # tuple
a,b => a+b # lambda
```

Container?
```
list(1 2) == list{int}(1 2)
dict(1 2 3 4) == dict{int int}(1 2 3 4)
```

Type
```
func(int int int)
struct(x:1 y:2)
struct(k,v => values:list(tuple(k v)))
enum(true:_ false:_)
enum(l,r => left:l right:r)
fix(enum(t,a => node:a tree:struct(left:t(a) right:t(a)))
struct(a => add:func(a a a) sub:func(a a a) mul:func(a a a))
```



## 2. Definition

```
pi = 3.14
add = a,b => a + b
```



## 3. Expression

Binary operation
```
1 + 2 * 3
```

Branch
```
if(n==0 "zero" "many")
case(n
  0 "zero"
  1 "one"
  _ "many")
```

Effect
```
eff(
  value: effect(1)
  func)
```

Helper?
```
tokenize = src => pure(top
  pos:0
  tokens:[]
  top = eff(
    t <- read_num.or(read_op)
    tokens.append(t)
    top.or(tokens))
  read_num = many1(any("0123456789".list)).map(.int)
  read_op = any("+-*/".list)
  many1 = f => eff(
    c <- f
    cs <- many(f)
    cs.prepend(c))
  many = f => eff(
    c <- f
    [f].append(many(f))).or([])
  any = ary => ary.first(satisfy)
  satisfy = f => with(skip
    c = src.char(pos)
    skip = if((c==" " || c=="\n") eff(pos+=1; skip) try)
    try = if(f(c) eff(pos+=1; c) nil)))
```



## 4. Syntax
```
root: def (br def)*
def:
| id "=" exp
exp: unit (op2 exp)?
unit:
| literal
| id ("." id ("(" arg+ ")")?)*
| "(" id ("," id)* "=>" exp ")"
| "(" exp ")"
literal:
| [0-9]+ ("." [0-9]+)?
| '"' [^"]* '"'
| "true"
| "false"
| "nil"
id : [a-z0-9_]+
op2: [+ - * / > >= < <=  == != || &&]
op2u: [: = <- ; := += *= /=]
arg: (id op2u)? unit
```

Buildin
# any
- string: string
# int
# string
- slice: int int string
- sub: string string string
- int: opt(int)
- trim: string
# bool
- if a: a a a
- then a: opt(a)
# list a
- size: int
- first: opt(a)
- slice: int int string
- map b: (a b) list(a)
- keep: (a bool) list(a)
# opt a | nil | some a
- or: opt(a) opt(a)
- and b: opt(b)
- then b: (a b) opt(b)
- catch b: (error b) b
- ignore b: b
# try a | opt(a) | error string
- then b: (a b) try(b)
- and b: try(b)
- ignore b: try(b)
