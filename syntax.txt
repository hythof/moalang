top: line*
line: keyword? exp+ ("\n" | (":\n" ("  " line)+))
exp: unit (op2 exp)*
unit: op1? bottom (prop | call | init | at)*
prop: "." id
call: "(" exp+ ")"
init: "{" (id ":" exp)+ "}"
at: "[" exp "]"
bottom:
| "(" exp ")"                  # priority  : 1 * (2 + 3)
| "[" exp* "]"                 # array     : [], [1 2]
| "{" (exp exp)* "}"           # dictionary: {}, {a "a" (1 + 2) "b"}
| '"' [^"]* '"'                # string    : "hi"
| '`' ("$" unit | [^"])* '`'   # template  : `hi $user.name`
| '"' [^"]* '"'                # regexp    : r"hi"
| id ("," id)* "=>" exp        # lambda    : a,b => a + b
| [0-9]+ ("." [0-9]+)?         # number    : 1, 0.5
| id                           # id        : name
id: [A-Za-z_][A-Za-z0-9_]*
op1: "!"
op2: [+-/%*=<>|&^;]+
keyword: qw(let var fn ft struct if return match case fail adt test)


# Idea for match/case
"match" exp id?:
  ("case" exp ("if" exp)? ":" line+ br)+

enum tree a:
  empty
  node:
    value a
    left tree(a)
    right tree(a)

type validate: tree(_) bool
fn validate target_tree:
  match target_tree t:
    case empty: true
    case node{left:node} if t.value < t.left.value: false
    case node{right:node} if t.value > t.right.value: false
    case node: validate(t.left) && validate(t.right)

enum ast:
  integer int
  op2:
    op string
    lhs ast
    rhs ast

type calc: ast ast int
fn calc target_ast:
  match target_ast a:
    case integer: a
    case op2{op:"/" rhs:0}: throw "zdiv"
    case op2{op:"+"}: calc(a.lhs) + calc(a.rhs)
    case op2{op:"-"}: calc(a.lhs) - calc(a.rhs)
    case op2{op:"*"}: calc(a.lhs) * calc(a.rhs)
    case op2{op:"/"}: calc(a.lhs) / calc(a.rhs)
    case op2: throw "Unknown operation ${a.op}"

# Ideas for bottom
| "(" id* (id ":" exp)* ")"    # struct    : (), (one=one), (one two three=3)
| id ("," id)* "=>" exp        # lambda    : a,b => a + b
| id ("," id)* ":" exp         # lambda    : f(x: x), (a,b: a + b)
| "\" id+ "=>" exp             # lambda    : \a b => a + b


# Ideas for function
ft f1: int (b=string c=int?)
fn f1 a (b="default" c?): ...
ft f2: int? (b=string c=int?)?
fn f2 a? (b="default" c?)?: ...
fn main:
  f1 1 b="something"
  f1 1 b="something" c=2
  f2
  f2 1
  f2 (b="something")
  f2 (b="something" c=3)


# Symbols
_          part of id
.          delimitor to access field or method of object
" `        string
#          comment
+ - * / %  calculation
( )        priority
[ ]        list
{ }        dictionary
< > =      comparing
,          delimitor for arguments in lambda expression
:          delimitor between reserved words and the following block which defined indent
\ undefined
^ undefined
? undefined
@ undefined
& undefined
| undefined
~ undefined
' undefined
! undefined
$ undefined
; undefined
