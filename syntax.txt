# Syntax
top: line*
line: keyword? exp+ ("\n" | (":\n" ("  " line)+))
exp: unit (op2 exp)*
unit: op1? bottom (prop | call | init | at)*
prop: "." id
call: "(" exp* ")"
init: "{" (id ":" exp)* | exp* "}"
at: "[" exp "]"
bottom:
| "(" exp (";" exp)* ")"         # priority   : 1 * (2 + 3), (a+=1; b)
| "[" exp* "]"                   # list       : [], [1 2]
| "[" (":" | id ":" unit) "]"    # dictionary : [:], [a:1 ("b"):(2+3)]
| "{" (id ":" unit)* "}"         # object     : {}, {a b:1}
| '"' [^"]* '"'                  # string     : "hi"
| '`' ("$" unit | [^"])* '`'     # template   : `hi $user.name`
| ("()" | id ("," id)*) "=>" exp # lambda     : a,b => a + b
| [0-9]+ ("." [0-9]+)?           # number     : 1, 0.5
| id                             # id         : name
id: [A-Za-z_][A-Za-z0-9_]*
op1: [!-]
op2: [+-/%*=<>|&^]+
keyword: qw(let var fn ft class enum if else match case raise try catch return for while continue break test)

# Basic types
- Value
  - bool        # true, false
  - int         # 1, -1
  - float       # 1.0, -1.0
  - string      # "hi", `hi $(name)`
  - lambda      # a,b => a + b # (int int int)
- Reference
  - opt         # some(1).then(x,x+1).else(-1), none # opt(int)
  - object      # {}, {a b:1 c:{d:2}}                # {a:bool b:int c:{d:int}}
- Container
  - bytes       # bytes(8), bytes{ 1 2 3 } # bytes
  - list        # [1 2]                    # list(int){ 1 2 }
  - set         # [1 2].uniq               # set(int){ 1 2 }
  - dictionary  # [a:1 (b):(1+2)]          # dict(string int){ a:1 (b):(1+2) }
- Definition
  - variable    # var a 1
  - constant    # let a 1
  - function    # fn a: 1, fn a b: b
  - class       # class a: b c
  - enum        # enum a: b; c d
- Statement
  - if          # if a: b; else if c: d; else: e
  - return      # return 1
  - exception   # try (raise a): catch a: b; catch _: c
  - for         # for a 9: b, for a 1 9: b, for a 1 9 2: b
  - while       # while a: b
  - continue    # continue
  - break       # break
  - yield       # yield a
- Misc
  - module      # module a: inc int int; use a inc
  - comment     # # this is comment
  - test        # test: ....
  - log         # log.debug "message"
  - time        # time.now.year
  - random      # random.float, random.int(1 6), random.string("a" "z"), random.bytes(32)
  - json        # json.encode(a), json.decode(a), json.map(a b)

# Symbols
_          part of id
.          access field or method of object
" `        string
#          comment
! -        singular operator
+ - * / %  binary operators
( )        priority
[ ]        list or dictionary
{ }        object
< > =      comparing
,          delimiter to arguments in anonymous function
:          delimiter between reserved words and a following block
\ undefined
^ undefined
? undefined
@ undefined
& undefined
| undefined
~ undefined
' undefined
$ undefined
; undefined


# Memo
- unify definition syntaxes
  - variable    # var a 1
  - constant    # let a 1
  - function    # fn a: 1, fn a b: b
  - class       # class a: b c
  - enum        # enum a: b; c d
- invent better lambda syntax
    a,b => a + b
    a,b,a+b
    a,b:a + b
    a,b~a + b
    a,b$a + b
    a,b@a + b
    a,b;a + b
    a,b^a + b
    a,b$a + b
    a,b?a + b
    _ . \ ! ~ + - * / % & | = " ' ` # ( ) [ ] { } < >
    ,
    ;
    @
    ^
    $
    ?


# Done
[x] define optional arguments
    | ft f1 a opt({b:int c:opt(int)}) int
    | fn f1 a {b c}: a + b + c.else(-1)
    | fn main:
        f1 1    # 0
        f1 1 {} # 0
        f1 1 {b:2 c:3} # 6
[x] match/case syntax
  "match" exp id?:
    ("case" exp ("if" exp)? ":" line+ br)+

  enum tree a:
    empty
    node:
      value a
      left tree(a)
      right tree(a)

  ft validate: tree(_) bool
  fn validate t:
    match t:
      case {left:node} if t.value < t.left.value: false
      case {right:node} if t.value > t.right.value: false
      case _: true

  enum ast:
    value int
    op2:
      op string
      lhs ast
      rhs ast

  ft calc: ast ast int
  fn calc a:
    match a:
      case value: a
      case {op:"/" rhs:0}: raise "zdiv"
      case {op:"+"}: calc(a.lhs) + calc(a.rhs)
      case {op:"-"}: calc(a.lhs) - calc(a.rhs)
      case {op:"*"}: calc(a.lhs) * calc(a.rhs)
      case {op:"/"}: calc(a.lhs) / calc(a.rhs)
      case _: raise `Unknown operation $(a.op)`
