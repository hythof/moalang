# Core syntax
top: line*
line: keyword? exp+ ("\n" | (":\n" ("  " line)+))
exp: unit (op2 exp)*
unit: op1? bottom (prop | call)*
call: "(" exp* ")"
prop: "." id
bottom:
| "(" exp ")"          # priority : 1 * (2 + 3), (a+=1; b)
| '"' [^"]* '"'        # string   : "hi"
| [0-9]+ ("." [0-9]+)? # number   : 1, 0.5
| id                   # id       : name
id: [A-Za-z_][A-Za-z0-9_]*
op1: [!-]
op2: [+-/%*=<>|&^;]+
keyword: qw(let var fn ft class union if else switch case throw catch return yield for each while continue break yield use test)
reserved: qw(bool int float string lambda i8..64 u8..64 f32 f64 list set bytes dict tuple object true false scopy dcopy)

# Syntax sugar
| bottom "[" exp "]"                   # bottom.get(exp)
| bottom "[" exp1 "]" = exp2           # bottom.set(exp exp)
| bottom{ ((id ":" exp)* }             # scopy bottom id exp ...
| bottom{:}                            # dcopy bottom
| "(" exp ("," exp)+ ")"               # (1, "hi")             : tuple 1 "hi"
| "[" exp* "]"                         # [], [1 2]             : list, list 1 2
| "[" (":" | id ":" unit) "]"          # [:], [a:1 (id):(2+3)] : dict, dict "a" 1 id (2+3)
| "{" id* (id ":" unit)* "}"           # {}, {a b:1}           : object, object a a b 1
| '`' ("$" unit | [^"])* '`'           # `hi $user.name`       : "hi %v".format user.name
| ("()" | id ("," id)*) "=>" exp       # a,b => a + b          : lambda a b: a + b
| exp ("\n|" exp ("if" exp)? ":" exp)+ # switch exp: case exp: exp ...

# Example
- Primitive
  - bool        # true, false
  - int         # 1, -1
  - float       # 1.0, -1.0
  - string      # "hi", `hi $(name)`
  - lambda      # () => 1,  a,b => a + b               # (int int int)
- Container
  - list        # [1 2]                    # list[int](1 2)
  - set         # [1 2].uniq               # set[int](1 2)
  - bytes       # bytes(1024)              # bytes
  - dict        # [a:1 (b):(1+2)]          # dict[string int](a:1 (b):(1+2))
  - tuple       # (1, "hi")                # tuple(1 "hi"), tuple[int string](1 "hi")
  - object      # {a:b c:d,e=>f(d e)}      # object(a b c d,e=>f(d e))
- Definition
  - variable    # var a 1
  - constant    # let a 1
  - function    # fn a: 1, fn a b: b
  - class       # class a: b c
  - union       # union a: b; c d
- Statement
  - if          # if a: b; else if c: d; else: e
  - return      # return 1
  - exception   # catch throw(f()) e => type: a; _: c
  - for         # for i 9: n += i
  - each        # each i [1 2]: n += i
  - while       # while a: b
  - continue    # continue
  - break       # break
  - yield       # yield 1; yield 2 # iterator[int]
- Misc
  - module      # module a: inc int int; use a inc
  - comment     # # this is comment
  - test        # test "name": ....

# Symbols
_           part of id
.           access an element of object
"           string
`           string with variables
#           comment
! -         singular operator
++ --       binary operator for container
&& ||       binary operator for boolean
+ - * / %   binary operator for number
| & ^       binary operator for int(or, and, xor)
( )         priority
[ ]         list or dict
{ }         object
< > ==      comparing
=           update existing a variable
,           delimiter to tuple and arguments in anonymous function
:           delimiter to start indented block
\ undefined
? undefined
@ undefined
~ undefined
' undefined
$ undefined
; undefined


# Idea for shorthand
- if expression
if bool 1          # option[int]
if bool 1 2        # int
if bool 1 bool 2   # option[int]
if bool 1 bool 2 3 # int
if a b c d e       #
a ? b : c ? d : e

- (breaking change) let and function with arguments
n = 1               # let n 1
f = () => time.now  # fn f: time.now
f a = a + 1         # fn f a: a + 1
a := 1              # override existing variable


# Pending ideas
- shorter lambda syntax
() => 1
a => a
a,b => a + b

fun: 1
fun a: a
fun a b: a + b

(:1)
(a: a)
(a,b: a + b)

:1
a: a
a,b: a + b

|1
a| a
a,b| a + b

'1         #  () => 1
a' a       #   a => a
a,b' a + b # a,b => a + b

> a,b => a + b
> (: "zero argument function body here")
> (a: a + 1)
> (a,b: a + b)
> add = (a b: a + b)
> a,b,a+b
> a,b:a + b
> a,b~a + b
> a,b$a + b
> a,b@a + b
> a,b;a + b
> a,b^a + b
> a,b$a + b
> a,b?a + b
> _ . \ ! ~ & | = ' #
> ,
> ;
> @
> ^
> $
> ?
