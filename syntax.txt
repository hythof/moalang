top: line*
line: keyword? exp+ ("\n" | (":\n" ("  " line)+))
exp: unit (op2 exp)*
unit: op1? bottom (prop | call | at)*
prop: "." id
call: "(" exp+ ")"
at: "[" exp "]"
bottom:
| "(" exp ")"                  # priority  : 1 * (2 + 3)
| "[" exp* "]"                 # array     : [], [1 2]
| "{" (exp exp)* "}"           # dictionary: {}, {a "a" (1 + 2) "b"}
| '"' [^"]* '"'                # string    : "hi"
| '`' ("$" unit | [^"])* '`'   # template  : `hi $user.name`
| '"' [^"]* '"'                # regexp    : r"hi"
| id ("," id)* "=>" exp        # lambda    : a,b => a + b
| [0-9]+ ("." [0-9]+)?         # number    : 1, 0.5
| id                           # id        : name
id: [A-Za-z_][A-Za-z0-9_]*
op1: "!"
op2: [+-/%*=<>|&^;]+
keyword: qw(let var fn ft struct if return switch case fail adt test)


# Ideas for bottom
| "(" id* (id ":" exp)* ")"    # struct    : (), (one=one), (one two three=3)
| id ("," id)* "=>" exp        # lambda    : a,b => a + b
| id ("," id)* ":" exp         # lambda    : f(x: x), (a,b: a + b)
| "\" id+ "=>" exp             # lambda    : \a b => a + b


# Ideas for function
ft f1: int (b=string c=int?)
fn f1 a (b="default" c?): ...
ft f2: int? (b=string c=int?)?
fn f2 a? (b="default" c?)?: ...
fn main:
  f1 1 b="something"
  f1 1 b="something" c=2
  f2
  f2 1
  f2 (b="something")
  f2 (b="something" c=3)


# Symbols
_          part of id
.          delimitor to access field or method of object
" `        string
#          comment
+ - * / %  calculation
( )        priority
[ ]        list
{ }        dictionary
< > =      comparing
,          delimitor for arguments in lambda expression
:          delimitor between reserved words and the following block which defined indent
\ undefined
^ undefined
? undefined
@ undefined
& undefined
| undefined
~ undefined
' undefined
! undefined
$ undefined
; undefined
