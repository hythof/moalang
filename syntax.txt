# Syntax
top: line*
line: keyword? exp+ ("\n" | (":\n" ("  " line)+))
exp: unit (op2 exp)*
unit: op1? bottom (prop | call | at)*
prop: "." id
call: "(" exp* ")"
at: "[" exp "]"
bottom:
| "(" exp ")"                    # priority   : 1 * (2 + 3), (a+=1; b)
| "[" exp* "]"                   # list       : [], [1 2]
| "[" (":" | id ":" unit) "]"    # dict       : [:], [a:1 ("b"):(2+3)]
| "{" id* (id ":" unit)* "}"     # object     : {}, {a b:1}
| '"' [^"]* '"'                  # string     : "hi"
| '`' ("$" unit | [^"])* '`'     # template   : `hi $user.name`
| ("()" | id ("," id)*) "=>" exp # lambda     : a,b => a + b
| [0-9]+ ("." [0-9]+)?           # number     : 1, 0.5
| id                             # id         : name
id: [A-Za-z_][A-Za-z0-9_]*
op1: [!-]
op2: [+-/%*=<>|&^;]+
keyword: qw(let var fn ft class union if else match case raise try catch return for while continue break test)

# Example
- Primitive
  - bool        # true, false
  - int         # 1, -1
  - float       # 1.0, -1.0
  - string      # "hi", `hi $(name)`
  - bytes       # bytes{ 0xEF 0xBB oxBF }, bytes(1024) # bytes
  - lambda      # a,b => a + b # (int int int)
- Container
  - list        # [1 2]                    # list(1 2), list(int){ 1 2 }
  - set         # [1 2].uniq               # set(1 2), set(int){ 1 2 }
  - dict        # [a:1 (b):(1+2)]          # dict({a:1 (b):(1+2)})
  - tuple       # (1, "hi")                # tuple(1, "hi"), tuple(int string){ 1 "hi" }
- Definition
  - variable    # var a 1
  - constant    # let a 1
  - function    # fn a: 1, fn a b: b
  - class       # class a: b c
  - union       # union a: b; c d
- Statement
  - if          # if a: b; else if c: d; else: e
  - return      # return 1
  - exception   # try (raise a): catch a: b; catch _: c
  - for         # for a 9: b, for a 1 9: b, for a 1 9 2: b
  - while       # while a: b
  - continue    # continue
  - break       # break
  - yield       # yield a
- Misc
  - module      # module a: inc int int; use a inc
  - comment     # # this is comment
  - test        # test "name": ....

# Symbols
_          part of id
.          access field or method of object
" `        string
#          comment
! -        singular operator
+ - * / %  binary operators
( )        priority
[ ]        list or dictionary
{ }        object
< > =      comparing
,          delimiter to arguments in anonymous function
:          delimiter between reserved words and a following block
\ undefined
^ undefined
? undefined
@ undefined
& undefined
| undefined
~ undefined
' undefined
$ undefined
; undefined


# Ideas
- unify definition syntaxes
  - variable    # var a 1
  - constant    # let a 1
  - function    # fn a: 1, fn a b: b
  - class       # class a: b c
  - union       # num a: b; c d
- invent better lambda syntax
    a,b => a + b
    a,b,a+b
    a,b:a + b
    a,b~a + b
    a,b$a + b
    a,b@a + b
    a,b;a + b
    a,b^a + b
    a,b$a + b
    a,b?a + b
    _ . \ ! ~ + - * / % & | = " ' ` # ( ) [ ] { } < >
    ,
    ;
    @
    ^
    $
    ?


# Done
[x] define optional arguments
    | ft f1 a opt({b:int c:opt(int)}) int
    | fn f1 a {b c}: a + b + c.else(-1)
    | fn main:
        f1 1    # 0
        f1 1 {} # 0
        f1 1 {b:2 c:3} # 6
[x] match/case syntax
  "match" exp id?:
    ("case" exp ("if" exp)? ":" line+ br)+

  enum tree a:
    empty
    node:
      value a
      left tree(a)
      right tree(a)

  ft validate: tree(_) bool
  fn validate t:
    match t:
      case {left:node} if t.value < t.left.value: false
      case {right:node} if t.value > t.right.value: false
      case _: true

  enum ast:
    value int
    op2:
      op string
      lhs ast
      rhs ast

  ft calc: ast ast int
  fn calc a:
    match a:
      case value: a
      case {op:"/" rhs:0}: raise "zdiv"
      case {op:"+"}: calc(a.lhs) + calc(a.rhs)
      case {op:"-"}: calc(a.lhs) - calc(a.rhs)
      case {op:"*"}: calc(a.lhs) * calc(a.rhs)
      case {op:"/"}: calc(a.lhs) / calc(a.rhs)
      case _: raise `Unknown operation $(a.op)`
