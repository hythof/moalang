- Design for error handling
[x] idt ::= id ("::" type)
[x] type :: = id ("{" id type+ (";" id type+)* "}")? | "(" type+ ")"
[ ] "throw" exp+
[ ] "try" exp+ ":" (br "catch" type id: exp)+
- f() |zdiv "zero"
- f() |zdiv e => f(e)
- f() |zdiv e => throw "some error" e

type of errors
- no parameter errors                                      # throw
- with message                                             # throw "unreachable"
- invalid input                                            # throw "invalid input"
- os error (EAGAIN, EINTR, ENOENT, ENOTDIR, ETIMEOUT, ...) # throw os(...)

nothing    -> error(_)
string     -> error(string)
uniqueness -> error(symbol?)
parameters -> error(type)
struct errror t:
  cause t
  message string # type name or message of throw
  backtrace string
887 : no specific type
383 : unique
127 : string
115 : numbers

throw                     # error(void)
throw "..."               # error(string)
throw type(parameters...) # error(type)
catch "...":              # catch a specific message
catch type:               # catch a specific type
catch type variable:      # catch a specific type with an error instance
catch _ e:                # catch all with an errorr instance
try exp...:
  catch "specific string" s: ...
  catch string s: ...
  catch type: ...
  catch type e: ...
  catch _ e: ...

- Design for no argument function
[x] "fn f: 1" # "(int)"
[x] "let v 1" # "int"

- Design something looks like statements
[x] "for" int ":" ...  | "for" id int int? int? ":" ...
[x] "while" exp ":" ...
[x] "if" exp ":" ... (br "else if" exp ":" ...)* ("else:" ...)?
[x] "continue" | "break" | "yield" exp | "yeild break"

- Design how to infer type of property access
[x] f x = x.inc (x.val + 1) # f a b{inc num a; val num} :: b a

- Shortcut for string template
[x] $"This is {name}"

- Design name space and multiple files
[x] "def" id (":" br indent id type+ "::" type+)?
[ ] "use" id+

- Implement methods

- log
[ ] debug, info, warn, error :: any+ any

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] at :: int string
[ ] slice :: int int string
[ ] split :: string list(string)
[ ] index :: string list(int)
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] tr :: string string int? string

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @index
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] empty :: bool
[ ] present :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @key
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] include :: k bool
[ ] empty :: bool
[ ] present :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] include :: a bool
[ ] empty :: bool
[ ] present :: bool

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now

- regexp
[ ] split :: string list(string)
[ ] find :: string list(string)
[ ] replace :: (string string) string

- lambda
