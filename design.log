# TODO
- [ ] Design to handle exceptions and optional
  - transpatrency : let x f(a.b())
  - block handling:
    let x try f(...) e => match e:
      case a: g(e.a)
      case b: h(e.b)
      case _:
        c
        continue
  idea 1: let x try a e => match e: catch error: b
  idea 2: let x a @ b
  idea 3: let x a ||| b

# Do
Primitive
- int
- float
- string
- function
- tuple
Expression
- single operators
- binary operators
Container
- list
- dictionary
- set
Flow
- if / else
- try / catch
- for / while / continue / break
- return
Type
- annotation
- optional
- cast
- class
- enum
- interface
- extension
Module
- use
- export
- package manager
IO
- time
- log
- object database management system
- extern
- web
- console
Command line
- format: moa <command> [arguments]
- moa         # show help
- moa shell   # interactive
- moa run     # execute
- moa build   # compile to executable file
- moa test    # run tests
- moa go      # compile to Go
- moa js      # compile to JavaScript
- moa swift   # compile to Swift
- moa java    # compile to Java

# Do not
- Memory management
- Inheritance
- Class based access control
- Unnecessary symbols like semi-corron, comma and parenthiese
- Strict access control like private

# Embedded objects
- bool
[ ] flip :: bool

- int
[ ] / :: int int float
[ ] + - * ** // % :: int int int
[ ] abs :: int
[ ] neg :: int
[ ] char :: string

- float
[ ] + - * ** / // % :: float float float
[ ] abs :: float
[ ] neg :: float
[ ] floor :: int
[ ] ceil :: int

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] pos :: int
[ ] at :: int string @error
[ ] slice :: int int string
[ ] split :: string int? list(string)
[ ] index :: string int @error
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] ord :: int
[ ] match :: string list(string)
[ ] rsplit :: string list(string)
[ ] rreplace :: string (list(string) string) int? string
[ ] bool :: bool

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @error
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] find :: (a bool) a @error
[ ] bool :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @error
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] find :: (k v bool) tuple(k v) @error
[ ] bool :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] includes :: a bool
[ ] bool :: bool

- tuple(a b ...)
[ ] 0 :: a
[ ] 1 :: b

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now

- log
[ ] debug, info, warn, error :: any+ any

- http
[ ] listen string (http.request http.response) ?
[ ] request string {method headers body} http.response

- odb
[ ] permanent a a
[ ] transaction (void)


----------------------------------------------------------------------------------------------------------------


[x] do not pick :symbol up from Ruby because `:a == "a"` is false that confuses developers

[x] Design match/case for enum
enum tree a:
  empty
  node:
    value a
    left tree(a)
    right tree(a)

def validate bt:
  match bt:
    case {left:node right:node}: (bt.left.value < bt.value < bt.right.value) && validate(bt.left) && validate(bt.right)
    case {left:node}: bt.left.value < bt.value && validate(bt.left.value)
    case {right:node}: bt.value < bt.right.value && validate(bt.right.value)
    case _: true

- Design for error handling
[x] "throw" exp?
[x] "try" exp (id "=>" exp)
try f() e => 1
try f() e => match e:
  case zdiv: true
  case {errno}: e.errno == 0
  caes: e.message != "dummy"

type of errors
- no parameter errors # throw
- with message        # throw "unreachable"
- with parameters?    # throw {id:123 obj:f()}

# raise exception
type throw a b: a b
throw(string)
throw(type(...))

# fallback exception
type try a b: expected(a b) (error(b) a) a
try(f(a b) _ => fallback())
try(f(a b) e => e.thrown)

# catch exceptions
type f: (int expected(string "zdiv"|string|bad|signal)) string
def f g:
  try g(1) e => match e:
    case "zdiv": "zero division error"
    catch string: e.thrown
    catch bad: `bad error $e.thrown.errno.string`
    catch: e.message

887 : no specific type
383 : unique
127 : string
115 : numbers


- Design for no argument function
[x] "fn f: 1" # "(int)"
[x] "let v 1" # "int"

- Design something looks like statements
[x] "for" int ":" ...  | "for" id int int? int? ":" ...
[x] "while" exp ":" ...
[x] "if" exp ":" ... (br "else if" exp ":" ...)* ("else:" ...)?
[x] "continue" | "break" | "yield" exp | "yeild break"

- Design how to infer type of property access
[x] f x = x.inc (x.val + 1) # f a b{inc num a; val num} :: b a

- Shortcut for string template
[x] $"This is {name}"

- Design name space and multiple files
[x] "def" id (":" br indent id type+ "::" type+)?
[x] "use" id+

