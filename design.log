- Design for error handling
[x] idt ::= id ("::" type)
[x] type :: = id ("{" id type+ (";" id type+)* "}")? | "(" type+ ")"
[x] "throw" exp+
[x] "try" exp+ ":" (br "catch" type id: exp)+

- Design for no argument function
[x] "fn f: 1" # "(int)"
[x] "let v 1" # "int"

- Design something looks like statements
[x] "for" int ":" ...  | "for" id int int? int? ":" ...
[x] "while" exp ":" ...
[x] "if" exp ":" ... (br "else if" exp ":" ...)* ("else:" ...)?
[x] "continue" | "break" | "yield" exp | "yeild break"

- Design how to infer type of property access
[x] f x = x.inc (x.val + 1) # f a b{inc num a; val num} :: b a

- Shortcut for string template
[x] $"This is {name}"

- Design name space and multiple files
[x] "def" id (":" br indent id type+ "::" type+)?
[ ] "use" id+

- Implement methods

- log
[ ] debug, info, warn, error :: any+ any

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] at :: int string
[ ] slice :: int int string
[ ] split :: string list(string)
[ ] index :: string list(int)
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] tr :: string string int? string

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @index
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] empty :: bool
[ ] present :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @key
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] include :: k bool
[ ] empty :: bool
[ ] present :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] include :: a bool
[ ] empty :: bool
[ ] present :: bool

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now

- regexp
[ ] split :: string list(string)
[ ] find :: string list(string)
[ ] replace :: (string string) string

- lambda
