[x] do not pick :symbol up from Ruby because `:a == "a"` is false that confuses developers

- Design for pattern match
enum tree a:
  empty
  node:
    value a
    left tree(a)
    right tree(a)

def validate bt:
  match bt:
    case empty: true
    case node{left:node} if bt.value < bt.left.value: false
    case node{right:node} if bt.value > bt.right.value: false
    case node: validate(bt.left) && validate(bt.right)


- Design for error handling
[ ] "throw" exp?
[ ] "try" exp exp+
try f() e => 1
in try f g:
  fn f: validate(node(1 empty empty))
  fn g (zdiv): true
  fn g (e:bad): e.errno == 0
  fn g e: false

- f(a b) | "zdiv" _ => -1
- f(a b) | "zdiv" e => f(e)
- f(a b) | "zdiv" e => throw "some error" e
- f(a b) | e => throw "some error" e
- f(a b){ "zdiv" -1, "zdiv" e => f(e), "zdiv" e => throw some error e }
- try f(a b) as e:
  catch zdiv: "zero"
  catch bad: e.value.errno.string
  catch: e.message
- try f(a b) as e:
  catch zdiv: "zero"
  catch bad: e.value.errno.string
  catch: e.message

type of errors
- no parameter errors                                      # throw
- with message                                             # throw "unreachable"
- invalid input                                            # throw "invalid input"
- os error (EAGAIN, EINTR, ENOENT, ENOTDIR, ETIMEOUT, ...) # throw os(...)

# raise exception
type throw a b: a b
throw(string)
throw(type(...))

# fallback exception
type try a b: expected(a b) (error(b) a) a
try(f(a b) _ => fallback())
try(f(a b) e => e.thrown)

# catch exceptions
type f: (int expected(string "zdiv"|string|bad|signal)) string
def f g:
  try g(1) e => match e:
    case "zdiv": "zero division error"
    catch string: e.thrown
    catch bad: `bad error $e.thrown.errno.string`
    catch: e.message

887 : no specific type
383 : unique
127 : string
115 : numbers

----------------------------------------------------------------------------------------------------------------

- Design for no argument function
[x] "fn f: 1" # "(int)"
[x] "let v 1" # "int"

- Design something looks like statements
[x] "for" int ":" ...  | "for" id int int? int? ":" ...
[x] "while" exp ":" ...
[x] "if" exp ":" ... (br "else if" exp ":" ...)* ("else:" ...)?
[x] "continue" | "break" | "yield" exp | "yeild break"

- Design how to infer type of property access
[x] f x = x.inc (x.val + 1) # f a b{inc num a; val num} :: b a

- Shortcut for string template
[x] $"This is {name}"

- Design name space and multiple files
[x] "def" id (":" br indent id type+ "::" type+)?
[ ] "use" id+

- Implement methods

- log
[ ] debug, info, warn, error :: any+ any

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] at :: int string
[ ] slice :: int int string
[ ] split :: string list(string)
[ ] index :: string list(int)
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] tr :: string string int? string

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @index
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] empty :: bool
[ ] present :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @key
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] include :: k bool
[ ] empty :: bool
[ ] present :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] include :: a bool
[ ] empty :: bool
[ ] present :: bool

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now

- regexp
[ ] split :: string list(string)
[ ] find :: string list(string)
[ ] replace :: (string string) string

- lambda
