# TODO
- [ ] Design to handle exceptions and optional
  - transpatrency : let x f(a.b())
  - block handling: let x try a: catch b{z}: c(z); catch d(y): e(y); catch _: f; g
  idea 1
  - alternative   : let x a ||| b
  - change flow   : let x a ||| b; continue
  - line handling : let x a |||b{z} c(z) |||d(y) e(y) ||| f; g
  idea 2
  - alternative   : let x try a _ => b
  - change flow   : let x try a: catch _: b; continue
  - line handling : let x try a: catch b{z}: c(z); catch d(y): e(y); catch _: f; g
  idea 3
  - alternative   : let x a @ b
  - change flow   : let x a @ b; continue
  - line handling : let x a @ b{z} ? c(z) : d(y) ? e(y) : f; g
  idea 4
  - `a @ b` could warn about `a` can throw tow or more types of exception
  - alternative   : let x a @ b
  - change flow   : let x a @ b; continue
  - line handling : let x a @b{z} c(z) @d(y) e(y) @ f; g
  idea 5
  - `a @ b` is same as `a @error b`. `throw` is same as `throw error`
  - `throw "failure"` is same as `throw error("failure")`
  - alternative   : let x a @ b
  - change flow   : let x a @ b; continue
  - sendmail(from to subject body) @ timeout: e{second (second > 30)} => throw slowTimeout(e.second)
  - line handling : let x a @ b{z}:c(z) d(y):e(y) f; g
  idea 6
  - alternative   : let x a or b
  - change flow   : let x a or b; continue
  - sendmail(from to subject body) or timeout: e{second (second > 30)} => throw 
- [ ] Short hand
  - let x if a == b: c else if d == e: f else: g
  - let x
    | a == b: c
    | d == e: f
    | g
  - let x a == b ? c : d == e ? f : g
  - let x match a: b ? c : d ? e : f
  match a:
    b ? c
    d ? e
    f ? g
  match a == b ? c : d:
    e ? f
    g ? h
    i ? j

# Embedded objects

- bool
[ ] flip :: bool

- int
[ ] / :: int int float
[ ] + - * ** // % :: int int int
[ ] abs :: int
[ ] neg :: int
[ ] char :: string

- float
[ ] + - * ** / // % :: float float float
[ ] abs :: float
[ ] neg :: float
[ ] floor :: int
[ ] ceil :: int

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] pos :: int
[ ] at :: int string @error
[ ] slice :: int int string
[ ] split :: string int? list(string)
[ ] index :: string int @error
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] ord :: int
[ ] match :: string list(string)
[ ] rsplit :: string list(string)
[ ] rreplace :: string (list(string) string) int? string
[ ] bool :: bool

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @error
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] find :: (a bool) a @error
[ ] bool :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @error
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] find :: (k v bool) tuple(k v) @error
[ ] bool :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] includes :: a bool
[ ] bool :: bool

- log
[ ] debug, info, warn, error :: any+ any

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now


----------------------------------------------------------------------------------------------------------------


[x] do not pick :symbol up from Ruby because `:a == "a"` is false that confuses developers

[x] Design match/case for enum
enum tree a:
  empty
  node:
    value a
    left tree(a)
    right tree(a)

def validate bt:
  match bt:
    case {left:node right:node}: (bt.left.value < bt.value < bt.right.value) && validate(bt.left) && validate(bt.right)
    case {left:node}: bt.left.value < bt.value && validate(bt.left.value)
    case {right:node}: bt.value < bt.right.value && validate(bt.right.value)
    case _: true

- Design for error handling
[x] "throw" exp?
[x] "try" exp (id "=>" exp)
try f() e => 1
try f() e => match e:
  case zdiv: true
  case {errno}: e.errno == 0
  caes: e.message != "dummy"

type of errors
- no parameter errors # throw
- with message        # throw "unreachable"
- with parameters?    # throw {id:123 obj:f()}

# raise exception
type throw a b: a b
throw(string)
throw(type(...))

# fallback exception
type try a b: expected(a b) (error(b) a) a
try(f(a b) _ => fallback())
try(f(a b) e => e.thrown)

# catch exceptions
type f: (int expected(string "zdiv"|string|bad|signal)) string
def f g:
  try g(1) e => match e:
    case "zdiv": "zero division error"
    catch string: e.thrown
    catch bad: `bad error $e.thrown.errno.string`
    catch: e.message

887 : no specific type
383 : unique
127 : string
115 : numbers


- Design for no argument function
[x] "fn f: 1" # "(int)"
[x] "let v 1" # "int"

- Design something looks like statements
[x] "for" int ":" ...  | "for" id int int? int? ":" ...
[x] "while" exp ":" ...
[x] "if" exp ":" ... (br "else if" exp ":" ...)* ("else:" ...)?
[x] "continue" | "break" | "yield" exp | "yeild break"

- Design how to infer type of property access
[x] f x = x.inc (x.val + 1) # f a b{inc num a; val num} :: b a

- Shortcut for string template
[x] $"This is {name}"

- Design name space and multiple files
[x] "def" id (":" br indent id type+ "::" type+)?
[x] "use" id+

