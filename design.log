# TODO
- Design to handle exceptions
  - transpatrency -- return type is defined regardless throwing exception
  - declare specific exceptions or not throwing
    f :: int int @zdiv # it can throw @zdiv
    f :: int int       # it does not throw any exception
  - block handling:
    x = try f(...) e => match e:
      case a: g e.a
      case b: h e.b
    let x try f(...) e => match e:
      case a: g(e.a)
      case b: h(e.b)
      case _:
        c
        continue
  idea 1: x = try a e => match e: catch error: b
  idea 2: x = a @ b
  idea 3: x = a ||| b

# Do
Primitive
- bool     : true false
- int      : 0
- float    : 0.1
- string   : ""          | `$(a + 1)`
- bytes    : "moa".bytes | [109 111 97].bytes
- tuple    : ()          | (a 1)
- function : f(1 2)      | def f a b: a + b
Expression
- single operators : !
- binary operators : + - * / % > >= < <= == != || && | & ++
Container
- list       : []    | [1 2]
- dictionary : [:]   | [a:1 (b):2 (c++d):3]
- set        : set() | set(a)
Flow
- if / then / else
- try / catch / alt
- for / while / continue / break
- return
Type
- annotation : div a.num :: a a a @zdiv
- struct     : struct vector2: x int; y int
- enum       : enum tree a: leaf; node: value a; left leaf(a) right leaf(a)
- interface
- extension
Module
- use
- export
- package manager
Development
- test
IO
- time
- random
- math
- log
- odb (object database management system)
- web
- extern
Command line
- format: moa <command> [arguments]
- moa                          # launch interactive shell
- moa build [go js swift java] # compile to a specific language
- moa test                     # run tests options: -coverage -benchmark -debug

# Do not
- API for OS
- Memory management
- Inheritance
- Class based access control
- Unnecessary symbols like semi-corron, comma and parenthiese
- Strict access control like private
- Providing multiple error handling like optional and exception

# Embedded objects
- bool
[ ] flip :: bool

- int
[ ] / :: int int float
[ ] + - * ** // % :: int int int
[ ] abs :: int
[ ] neg :: int
[ ] char :: string

- float
[ ] + - * ** / // % :: float float float
[ ] abs :: float
[ ] neg :: float
[ ] floor :: int
[ ] ceil :: int

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] pos :: int
[ ] at :: int string @error
[ ] slice :: int int string
[ ] split :: string int? list(string)
[ ] index :: string int @error
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] ord :: int
[ ] match :: string list(string)
[ ] rsplit :: string list(string)
[ ] rreplace :: string (list(string) string) int? string
[ ] bool :: bool

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @error
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] find :: (a bool) a @error
[ ] bool :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @error
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] find :: (k v bool) tuple(k v) @error
[ ] bool :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] includes :: a bool
[ ] bool :: bool

- tuple(a b ...)
[ ] 0 :: a
[ ] 1 :: b

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now

- log
[ ] debug, info, warn, error :: any+ any

- http
[ ] listen string (http.request http.response) ?
[ ] request string {method headers body} http.response

- odb
[ ] permanent a a
[ ] transaction (void)


----------------------------------------------------------------------------------------------------------------


[x] do not pick :symbol up from Ruby because `:a == "a"` is false that confuses developers

[x] Design match/case for enum
enum tree a:
  empty
  node:
    value a
    left tree(a)
    right tree(a)

def validate bt:
  match bt:
    case {left:node right:node}: (bt.left.value < bt.value < bt.right.value) && validate(bt.left) && validate(bt.right)
    case {left:node}: bt.left.value < bt.value && validate(bt.left.value)
    case {right:node}: bt.value < bt.right.value && validate(bt.right.value)
    case _: true

- Design for error handling
[x] "throw" exp?
[x] "try" exp (id "=>" exp)
try f() e => 1
try f() e => match e:
  case zdiv: true
  case {errno}: e.errno == 0
  caes: e.message != "dummy"

type of errors
- no parameter errors # throw
- with message        # throw "unreachable"
- with parameters?    # throw {id:123 obj:f()}

# raise exception
type throw a b: a b
throw(string)
throw(type(...))

# fallback exception
type try a b: expected(a b) (error(b) a) a
try(f(a b) _ => fallback())
try(f(a b) e => e.thrown)

# catch exceptions
type f: (int expected(string "zdiv"|string|bad|signal)) string
def f g:
  try g(1) e => match e:
    case "zdiv": "zero division error"
    catch string: e.thrown
    catch bad: `bad error $e.thrown.errno.string`
    catch: e.message

887 : no specific type
383 : unique
127 : string
115 : numbers


- Design for no argument function
[x] "fn f: 1" # "(int)"
[x] "let v 1" # "int"

- Design something looks like statements
[x] "for" int ":" ...  | "for" id int int? int? ":" ...
[x] "while" exp ":" ...
[x] "if" exp ":" ... (br "else if" exp ":" ...)* ("else:" ...)?
[x] "continue" | "break" | "yield" exp | "yeild break"

- Design how to infer type of property access
[x] f x = x.inc (x.val + 1) # f a b{inc num a; val num} :: b a

- Shortcut for string template
[x] $"This is {name}"

- Design name space and multiple files
[x] "def" id (":" br indent id type+ "::" type+)?
[x] "use" id+

