struct token:
  text string
  pos  int

enum ast:
  node token
  call list st
  stmt list st

def string o:
  iif:
    typeof o == "string": o
    Array.isArray(o)    : `(${o.map(string).join(" ")})` :
    JSON.stringify(o)
def put ...a: log(a.map(string).join(" ")); a[0]
def puts ...a: log(a.map(string).join(" ")); a[0]
def log o: log.inspect(o); o
def fail m ...a: throw m ++ ": " ++ a.map(string).join(" ")
def parse source:
  if source.trim().length == 0:
    return []

  let regexp "" #/([!+\-*/%<>:!=^|&]+|[()\[\]{}]|r?"[^]*?(?<!\\)"|r?"[^]*?(?<!\\)"|-?[0-9]+(?:\.[0-9]+)|[0-9A-Za-z_]+|(?:#[^\n]*|[ \n])+)/ // operator | parenthesis | string | number | id | comment and spaces
  let tokens source.trim().split(regexp).filter(s => s.length)
  tokens.append(token("" 0))

  var pos 0
  def peek:
    tokens[pos].text
  def read:
    iif peek().match(r"^[ #]"): tokens[pos+=1].text
      peek()
  def many f g:
    while pos < tokens.length && f(read()): yield g()
    #let a []
    #while pos < tokens.length && f(read()):
    #  a.push(g())
    #a
  def until s:
    def check t:
      pos += t.has("\n").int
      if read() == s:
        pos += 1
        return false
      true
    many(check parse_exp)
  def consume:
    let t read() ||| fail("out of index" pos tokens)
    pos += 1
    t
  def indent t:
    iif t.has("\n"::
      t.split("\n").at(-1).length
      fail "not break line" t
  def squash a:
    iif a.length == 1: node(a[0])
      call(a)
  def parse_unit:
    def suffix t:
      let close peek()
      let next read()
      iif:
        close == "(" : ++pos; suffix(call([t ...until(")")]))
        close == "[" : ++pos; suffix(call(["__index" t ...until("]")]))
        close == "," : suffix([t ...many(t => t == "," && bool(pos+=1) consume)])
        close == "." : ++pos; suffix([next t consume()])
        next  == "=>": ++pos; ["fn" t parse_block()]
        t
    suffix switch consume() t =>
      "!": [t parse_unit()]
      "-": [t parse_unit()]
      "[": call(["list"] ++ ...until("]"))
      "(": squash(until(")"))
      ":": parse_block()
       _ : t
  def parse_exp:
    let is_op2 read().match(r"^:?[!+\-*/%<>!=^~|&]") && s !== "!"
    iif is_op2 call([consume() parse_unit() parse_exp()]) parse_unit()
  def parse_line:
    squash(many(t => !t.includes("\n") && t !== ")" && t !== "]" parse_exp))
  def parse_lines n:
    stmt(many(t => t.has("\n") && indent(t) == n && bool(pos+=1) parse_line))
  def parse_block:
    let t read()
    iif t.has("\n"): parse_lines(indent(t))
      parse_line()
  parse_lines 0
