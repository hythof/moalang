struct token:
  text string
  pos  int

enum ast:
  node token
  call list st
  stmt list st

def parse source:
  if source.trim().size == 0:
    return stmt []

  # operator | parenthesis | string | number | id | comment and spaces
  let regexp r'([!+\-*/%<>:!=^|&]+|[()\[\]{}]|r?"[^]*?(?<!\\)"|r?"[^]*?(?<!\\)"|-?[0-9]+(?:\.[0-9]+)|[0-9A-Za-z_]+|(?:#[^\n]*|[ \n])+)'
  let tokens source.trim().split(regexp).filter(s => s.size > 0).mapi(token)

  var pos 0
  let eot token("" 0)
  def peek:
    iif pos < tokens.size:
      tokens[pos]
      eot
  def read:
    if peek().text.match(r"^[ #]"):
      pos += 1
    peek()
  def many f g:
    #while pos < tokens.size && f read(): yield g()
    let a []
    while pos < tokens.size && f(read()):
      let prev pos
      let item g()
      if prev == pos:
        break
      a.push item
    a
  def until s:
    def check t:
      pos += t.text.has("\n").int
      if read().text == s:
        pos += 1
        return false
      true
    many check parse_exp
  def consume:
    let t read()
    if t.text == "":
        throw "out of index" pos tokens
    pos += 1
    t
  def indent t:
    t.text.split("\n").at(-1).size
  def squash a:
    iif a.size == 1:
      a[0]
      call a
  def alias t a:
    node token(a t.pos)
  def parse_unit:
    def suffix t:
      let adjacent peek()
      let next read()
      iif:
        adjacent.text == "(" : pos += 1; suffix call([t] ++ until(")"))
        adjacent.text == "[" : pos += 1; suffix call([alias(adjacent "__index") t] ++ until("]"))
        adjacent.text == "." : pos += 1; suffix call([node(next) t node(consume())])
        next.text     == "=>": pos += 1; call [alias(next "fn") t parse_block()]
        next.text     == "," : suffix call([node(consume()) t node(consume())])
        t
    let t consume()
    suffix case(t.text:
      "!": call [node(t) parse_unit()]
      "-": call [node(t) parse_unit()]
      "[": call [alias(t "list")] ++ until("]")
      "(": squash until(")")
      ":": parse_block()
      _ : node t)
  def parse_exp:
    def is_op2 s:
      s.match(r"^:?[!+\-*/%<>!=^~|&]") && s != "!"
    let lhs parse_unit()
    iif is_op2(read().text):
      call [node(consume()) lhs parse_exp()]
      lhs
  def parse_line:
    def f t:
      !t.text.has("\n") && t.text != ")" && t.text != "]"
    squash many(f parse_exp)
  def parse_lines n:
    def f:
      let t peek()
      if t.text.has("\n") && indent(t) == n:
        pos += 1
      parse_line()
    stmt many((t => true) f)
  def parse_block:
    let t read()
    iif t.text.has("\n"):
      parse_lines indent(t)
      parse_line()
  parse_lines 0
