- Design for error handling
- Implement types
[x] bool
[x] int
[x] float
[x] num
[x] string
[x] list a
[x] set a
[x] dict k v
[x] tuple ...
[ ] regexp ...
[ ] match ...
[ ] user defined struct
[ ] user defined algebraic data type
- Implement methods

Exception?
[ ] throw a :: any
[ ] catch a b :: a b

# User defined type
[ ] struct
[ ] algebric data type

# Types and methods
- log
[ ] debug, info, warn, error :: a a

- binary operators
[ ] == !=
[ ] < > <= >=

- bool
[ ] ||, && :: bool bool bool

- num(a), int, float
[ ] + - * % :: a a a
[ ] < > <= >= :: a a bool
[ ] / :: a a a @zdiv

- string
[ ] ++ :: string string string
[ ] size :: int
[ ] at :: int string
[ ] slice :: int int string
[ ] split :: string list(string)
[ ] index :: string list(int)
[ ] replace :: string string int? string
[ ] reverse :: string
[ ] tr :: string string int? string

- list(a)
[ ] ++ a :: list(a) list(a) list(a)
[ ] size :: int
[ ] at :: int a @index
[ ] map b :: (a b) list(b)
[ ] filter :: (a bool) list(a)
[ ] slice :: int int list(a)
[ ] sort b :: (a b)? list(a)
[ ] reverse :: list(a)
[ ] zip b :: list(b) list(tuple(a b))
[ ] empty :: bool
[ ] present :: bool

- dict(k v)
[ ] size :: int
[ ] at :: k v @key
[ ] keys :: list(k)
[ ] values :: list(v)
[ ] filter :: (k v bool) dict(k v)
[ ] list :: list(tuple(k v))
[ ] include :: k bool
[ ] empty :: bool
[ ] present :: bool

- set(a)
[ ] size :: int
[ ] - :: set(a) set(a)
[ ] | :: set(a) set(a)
[ ] & :: set(a) set(a)
[ ] include :: a bool
[ ] empty :: bool
[ ] present :: bool

- tuple(t...)
[ ] 0, 1 ...

- time
[ ] year, month, day, hour, minute, sec, wday, mday, yday
[ ] time.now

- regexp
[ ] split :: string list(string)
[ ] find :: string list(match)
[ ] replace :: (match string) string

- match
[ ] string :: string
[ ] pos :: int

- lambda

# Commercial features
[ ] use mrpc define




# Idea for the exception
div a 0 = @zdiv
div a b = a / b
calc =
  a = 10
  b = 0
  c = div a b |zdiv 0
main = net.http req =>
  s = req.query "s" |key throw bad-request
