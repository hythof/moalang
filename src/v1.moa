compile src = build(parse(src))
parse src = parser("1+2 - 3*4" 0).parse_top()
build node = node
| int = node.n
| op2 = build(node.left) + node.op + build(node.right)
| _ = node

ast enum:
  int n int
  string s string
  op2 op string, left ast, right ast
  apply target ast, argv [ast]

parser class:
  src string
  pos int

  parse_top = parse_exp()
  parse_exp =
    l = parse_unit()
    parse_op2(l) | l
  parse_op2 l =
    op = read_op()
    r = parse_exp()
    ast.op2(op l r)
  parse_unit = parse_int()
  parse_int = ast.int(read_int())

  read_op = spaces(); select("+-*/".to_a())
  read_int = spaces(); many1(() => select("0123456789".to_a())).join("").to_i()

  spaces =
    sp = " "
    many(() => eq(sp))
  many1 f = [f()].concat(many(f))
  many f = (rec acc = rec(acc.append(f())) | acc)([])
  select xs = satisfy(x => xs.contains(x))
  eq x =
    r = x == src.slice(pos pos + x.length)
    r || error("failed")
    pos += x.length
    x
  satisfy f =
    c = src.nth(pos)
    f(c) || error("failed")
    pos += 1
    c
