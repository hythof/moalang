help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source =
  nodes = parse source
  "const main = io => log.debug(io)"

union type:
  tundef # no type determined yet
  tnil   # for tag only union and field less struct
  tbool
  tint
  tfloat
  tstring
  tlambda list[type]
  tset type
  tlist type
  tdict type type
  ttype list[tuple[string type]]

union ast:
  adefine:
    id string
    desc ast
  abool bool
  aint int
  afloat float
  astring string
  atuple list[ast]
  astatement list[ast]
  alambda:
    args list[string]
    body ast
    type type
  aref:
    id string
    type type
  acall:
    head ast
    argv list[ast]

parse source =
  # list[string]
  tokens =
    trim a = iif:
      a.size == 0: []
      a[0].match("^[ \r\n\t]"): trim a.slice 1
      a[-1].match("^[ \r\n\t]"): trim a.slice 0 -1
      _: a
    regexp = r"""((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\r\n]+(?:#[^\n]*|[ \t\r\n]+)*|"(?:[^"]|\\")*(?<!\\)"|[A-Za-z0-9_]+|#[^\n]*)"""
    source.rsplit(regexp).keep(t => t.size > 0 && !t.starts("#"))
  pos = 0
  statement = () =>
    bottom = () =>
      t = tokens[pos]
      iif:
        t == "true": abool true
        t == "false": abool false
        t.match "^[0-9.]+\.[0-9]+$": afloat t.float
        t.match "^[0-9]+": aint t.int
        t.starts "\"\"\"": astring t.slice(3 -3).replace("\\t", "\t").replace("\\n", "\n").replace("\\\"", "\"")
        t.starts "\"": astring t.slice(1 -1).replace("\\t", "\t").replace("\\n", "\n").replace("\\\"", "\"")
        t.starts "[": alist [] # TODO
        t.starts "[": adict [] # TODO
        t.match "^[a-zA-Z_]": aref t
        _: aref t
    #exp = () =>
      #adefine:
      #  id string
      #  desc ast
      #alambda:
      #  args list[string]
      #  body ast
      #  type type
      #aref:
      #  id string
      #  type type
      #acall:
      #  head ast
      #  argv list[ast]
    bottom()
  statement()
    #many a f = tokens.get(pos).then(t => f(t).then(x => many g++[x] f).alt(a)).alt(a)
    #many a f = match many(a ++ f(tokens[pos]) f):  .error: a
    #consume = () => tokens[pos += iif tokens[pos].match("^[ \t]+$") 2 1]
    #until end = many [] t => iif t == end pos+=1 unit()
    #call o a = iif a.size == 0 ["__call" o] [o] ++ a
    #index o a = ["__index" o] ++ a
    #dict a = (a.size / 3).times.fmap i => [string(a[i*i]) a[(i*3)+2]]
    #container a = match a:
    #  []          : ["__call" "list"]
    #  [":"]       : ["__call" "dict"]
    #  [_ ":" _ __]: ["dict"] ++ dict(a)
    #  _           : ["list"] ++ a
    #object a = iif:
    #  a.size == 0: ["__call" "class"]
    #  _: a.index(s => s === anodes && s[0] == "=").alt(["class"] ++ a).then x =>
    #    ["class"] ++ a.slice(0 pos).fmap(x => [x x]) ++ a.slice(pos).fmap(x => [x[1] x[2]])
    #bottom t = match t:
    #  _ if tokens[pos] == "."                 : pos +=1; ["." t consume()]
    #  _ if tokens[pos] == "="                 : pos +=1; ["=" t unit()]
    #  "." if tokens[pos - 2].match("^[ \t]+$"): [t consume()]
    #  "["                                     : container until("]")
    #  "{"                                     : object until("}")
    #  "("                                     : until(")")
    #  _                                       : t
    #unit = () =>
    #  f o = match tokens[pos]:
    #    "(" if "\t:".includes(tokens[pos - 1]): pos += 1; call o until(")")
    #    "[" if "\t:".includes(tokens[pos - 1]): pos += 1; call o index("]")
    #    _: o
    #  f bottom(consume())
    #indent s = iif s.match("[\r\n]") s.split("[\r\n]").slice(-1)[0].length -1
    #lines n =
    #  block a = match a[-1]:
    #    ":" if tokens[pos].match("[\r\n]"): a ++ [statement()]
    #    "=" if tokens[pos].match("[\r\n]"): a ++ [statement()]
    #    _: a
    #  line = () => block many([] t => t.match("[\r\n]") && unit())
    #  many [] t => iif indent(t) == n (pos += 1; line()) none
    #a = lines indent(tokens[pos])
    #iif a.size >= 2 ["pack"] ++ a a
#  const reorder = o => {
#    const is_op2 = s => typeof s === 'string' && binaryOps.includes(s)
#    const op2 = a => (!Array.isArray(a) || a.length <= 2) ? a :
#      is_op2(a[1]) ? op2([prioritize(a[1], a[0], a[2]), ...a.slice(3)]) :
#      [a[0], ...op2(a.slice(1))]
#    const prioritize = (op, l, r) => Array.isArray(l) && is_op2(l[0]) && priority(op) < priority(l[0]) ? [l[0], l[1], [op, l[2], r]] : [op, l, r]
#    const priority = op => binaryOps.findIndex(t => t == op)
#    const isId = o => typeof o === 'string' && /^[a-zA-Z_]/.test(o)
#    const block = a => (n => n === -1 ? a : [a[n], a.slice(0, n), a.slice(n+1)])(a.findIndex(t => t === ':'))
#    const declare = a => (pos => pos === -1 ? a : [a[pos], a.slice(0, pos), a.slice(pos+1)])(a.findIndex(t => t === '::' || t === '='))
#    const unnest = a => a.length === 1 ? a[0] : a
#    return Array.isArray(o) ? (o.length === 1 ? reorder(o[0]) : unnest(block(declare(op2(o)))).map(reorder)) : o
#  }
#  tokens.unshift('\n')
#  return reorder(statement())
#}


test t "parser":
  simplify a =
    match a:
      x.adefine   : x.id ++ " = " ++ simplify(x.desc)
      x.ablool    : string x
      x.aint      : string x
      x.afloat    : string x
      x.astring   : x
      x.astatement: x.map(simplify).join("\n")
      x.alambda   : x.args.join(",") ++ " => " ++ simplify(x.body)
      x.aref      : x.id
      x.acall     : simplify(x.head) ++ "(" ++ acall.argv.map(simplify).join(" ") ++ ")"
  t1 expectation ast = t.eq expectation simplify(ast)
  t1 "a = 1" adefine("a" aint(1))
  t1 "1" aint(1)
  t1 "1.1" afloat(1.1)
  t1 "hi" astring("hi")
  t1 "1\n2" astatement([aint(1) aint(2)])
  t1 "a,b => 1" alambda(["a" "b"] aint(1))
  t1 "a" aref("a")

  test expectation source = t.eq expectation simplify(parse(source))
  log.debug """"\\t\\n"""".slice(1 -1).replace("\\t", "\t").replace("\\n", "\n").replace("\\\"", "\"")

  # primitives
  test "1" "1"
  test "1.1" "1.1"
  test "id" "id"
  test "hi" "\"hi\""
  test "\t" "\"\\t\""
  test "hi" """"hi"""" # "
  test "\t" """"\\t"""" # "
##  test "(__call list)" "[]"
##  test "(list 1 2)" "[1 2]"
##  test "(__call dict)" "[:]"
##  test "(dict \"a\" 1)" "[a:1]"
##  test "(dict \"a\" (+ 1 2))" "[a:(1+2)]"
##  test "(dict (+ 1 2) (+ 3 4))" "[(1+2):(3+4)]"
##  test "(dict \"a\" 1 \"b\" (+ 1 2) c (+ 3 4))" "[a:1 b:(1+2) (c):(3+4)]"
##  test "(__call class)" "{}"
##  test "(class a 1)" "{a=1}"
##  test "(class a a b b c (+ 1 2) d 3)" "{a b c=(1+2) d=3}"
##  test "(=> a a)" "a => a"
##  test "(=> (, a b) a)" "a,b => a"
##  test "(=> p (+ 1 2))" "p => 1 + 2"
##  test "(. int)" ".int"
##  test "(f (. int))" "f .int"
  log.debug "ok"
##
##  # definition
##  test "(= a 1)" "a = 1"
##  test "(= (f a) a)" "f a = a"
##  test "(= (f a) (__pack (= b 1) (+ a b)))" "f a =\n  b = 1\n  a + b"
##
##  # property access
##  test "(. a b)" "a.b"
##  test "((. a b) c)" "a.b c"
##  test "(. (__call list) length)" "[].length"
##  test "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
##
##  # single operator
##  test "(! true)" "!true"
##
##  # binary operators
##  test "(+ 1 2)" "1 + 2"
##  test "(+ (+ 1 2) 3)" "1 + 2 + 3"
##  test "(!= 1 1)" "1 != 1"
##  test "(= a 1)" "a = 1"
##  test "(+= a 1)" "a += 1"
##  test "(= a (+ 1 2))" "a = 1 + 2"
##  test "(+= a (+ 1 2))" "a += 1 + 2"
##  test "(+ 1 (* 2 3))" "1 + 2 * 3"
##  test "(+ 1 (/ 2 3))" "1 + 2 / 3"
##  test "(+ 1 (% 2 3))" "1 + 2 % 3"
##  test "(+ 1 (// 2 3))" "1 + 2 // 3"
##
##  # parentheses
##  test "1" "(1)"
##  test "(f 1)" "(f 1)"
##  test "(+ 1 2)" "(1 + 2)"
##  test "(+ 1 (+ 2 3))" "1 + (2 + 3)"
##
##  # fu ction call
##  test "(__call f)" "f()"
##  test "(f 1)" "f(1)"
##  test "(f (+ 1 2))" "f(1 + 2)"
##
##  # method call
##  test "(. f m)" "f.m"
##  test "(. f 1)" "f.1"
##  test "(__call (. f m))" "f.m()"
##  test "((. f m) a)" "f.m(a)"
##  test "((. f m) a b)" "f.m(a b)"
##
##  # index access
##  test "(__index x 1)" "x[1]"
##  test "(__index x 1 2)" "x[1 2]"
##
##  # steps
##  test "(__pack a b)" "a\nb"
##  test "(__pack (a b) c)" "a b\nc"
##  test "(__pack a (b c))" "a\nb c"
##
##  # block
##  test "(: a b)" "a: b"
##  test "(: (a b) c)" "a b: c"
##  test "(: (a b) (c d))" "a b: c d"
##
##  # indent
##  test "(: a b)" "a:\n  b"
##  test "(: a (: b c))" "a:\n  b:\n    c"
##  test "(: a (: b (__pack c d)))" "a:\n  b:\n    c\n    d"
##  test "(: a (__pack (: b c) d))" "a:\n  b:\n    c\n  d"
##  test "(__pack (: a (: b c)) d)" "a:\n  b:\n    c\nd"
##  test "(__pack (: a (__pack b (: c d) e)) f)" "a:\n  b\n  c:\n    d\n  e\nf"
##
##  # combinations
##  test "(! (a b))" "!a(b)"
##  test "(+ (a b) c)" "a(b) + c"
##
##  # edge case
##  test "1" "1\n"
##  test "()" "n"
##  test "()" "\n"
