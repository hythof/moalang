help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source = "const main = io => log(io)"

class type:
  id string
  params list[type]

class token:
  fragment string
  indent int
  lineno int
  column int

union input:
  ivalue token
  icall list[input]
  istatement list[input]

union ast:
  abool bool
  aint int
  afloat float
  astring string
  alambda:
    args list[string]
    body ast
    type type
  aid:
    id string
    type type
  acall:
    head ast
    argv list[ast]
  adefine:
    id string
    body ast
  astatement list[ast]
  aop1:
    op string
    body ast
  aop2:
    op string
    lhs ast
    rhs ast
    type type
  aundef string

parse source =
  tokens =
    regexp = r"((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\n]+(?:#[^\n]*|[ \t\n]+)*|\"[^]*?(?<!\\)\"|[A-Za-z0-9_]+|#[^\n]*)"
    indent = 0
    lineno = 1
    column = 1
    source.rsplit(regexp).fmap fragment =>
      guard fragment == "": []
      guard fragment.has("\n"):
        indent := fragment.split("\n")[-1].size
        lineno += fragment.split("\n").size - 1
        column := indent
        []
      guard fragment.match(r"^[ \t\n#]"): []
      t = token fragment indent lineno column
      column += fragment.size
      t
  guard tokens.size == 0: istatement []
  pos = 0
  eq s = pos < tokens.size && f tokens[pos].fragment == s
  parse_unit = () =>
    until end =
      loop a =
        guard pos >= tokens.size: a
        guard tokens[pos].fragment == end:
          pos += 1
          a
        loop a ++ [parse_exp()]
      loop []
    consume = () =>
      guard pos >= tokens.size: aundef ""
      t = tokens[pos]
      pos += 1
      guard t.fragment == "(": icall until(")")
      guard t.fragment == "[": icall [ivalue(token("list" 0 0 0))] ++ until("]")
      guard t.fragment == ":": parse_block()
      ivalue t
    suffix x =
      guard pos >= tokens.size: x
      t = tokens[pos]
      guard t.fragment == ".":
        pos += 1
        field = tokens[pos]
        pos += 1
        suffix icall([ivalue(t) x ivalue(field)])
      guard t.fragment == "(":
        pos += 1
        argv = until(")")
        guard argv.size == 0: suffix icall([ivalue(t) x])
        suffix icall([x] ++ argv)
      guard t.fragment == "[":
        pos += 1
        suffix icall([ivalue(token("__index" 0 0 0)) x] ++ until("]"))
      x
    suffix consume()
  parse_exp = () =>
    lhs = parse_unit()
    guard pos >= tokens.size: lhs
    guard lhs == ivalue("!"): icall [lhs parse_unit()]
    lop = tokens[pos]
    op2s = ", * ** / // % + ++ - >> << ^ & | := += -= *= /= %= **= < <= > >= == != === !== <=> && || =>".split " "
    guard op2s.has(lop.fragment):
      pos += 1
      is_group = tokens[pos].fragment == "("
      rhs = parse_exp()
      guard !is_group && rhs === icall:
        rop = rhs[0]
        guard rop === ivalue && op2s.index(lop.fragment) < op2s.index(rop.fragment):
          icall [rhs[0] icall([ivalue(lop) lhs rhs[1]]) rhs[2]] # "1 * 2 + 3" -> (* 1 (+ 2 3)) -> (+ (* 1 2) 3)
        icall [ivalue(lop) lhs icall(rhs)]
      icall [ivalue(lop) lhs rhs]
    lhs
  parse_block = () =>
    guard pos >= tokens.size: fail "empty block"
    guard tokens[pos - 1].indent < tokens[pos].indent: parse_statement()
    parse_line()
  parse_line = () =>
    lineno_ = tokens[pos].lineno
    head = parse_exp()
    loop a =
      guard pos >= tokens.size || tokens[pos].lineno != lineno_: icall [head] ++ a
      guard tokens[pos].fragment == "=":
        define_token = tokens[pos]
        pos += 1
        guard a.size == 0: icall [ivalue(define_token) head parse_block()]
        lambda = icall [ivalue(token("=>" 0 0 0)) icall(a) parse_block()]
        icall [ivalue(define_token) head lambda]
      loop a ++ [parse_exp()]
    loop []
  parse_statement = () =>
    read_block indent lines =
      guard pos >= tokens.size || tokens[pos].indent != indent: istatement lines
      read_block indent lines ++ [parse_line()]
    guard pos >= tokens.size: istatement []
    read_block tokens[pos].indent []
  parse_statement()

test t "parser":
  stringify x =
    match x:
      x.ivalue    : x.fragment
      x.icall     :
        guard x.size == 1: stringify x[0]
        "(" ++ x.map(stringify).join(" ") ++ ")"
      x.istatement:
        guard x.size == 1: stringify x[0]
        "(" ++ x.map(stringify).join("; ") ++ ")"
  i1 = ivalue token("1" 0 0 0)
  test_stringify expectation input = t.eq expectation stringify(input)
  test_stringify "1"      i1
  test_stringify "(1 1)"  icall([i1 i1])
  test_stringify "(1; 1)" istatement([i1 i1])

  test_parser expectation source = t.eq expectation stringify(parse(source)) source

  # primitives
  test_parser "1" "1"
  test_parser "1.1" "1.1"
  test_parser "id" "id"
  test_parser "\"hi\"" "\"hi\""
  test_parser "\"\\t\"" "\"\\t\""
  test_parser "true" "true"
  # container
  test_parser "list" "[]"
  test_parser "(list 1 2)" "[1 2]"
  test_parser "(=> a a)" "a => a"
  test_parser "(=> (, a b) a)" "a,b => a"
  test_parser "(=> p (+ 1 2))" "p => 1 + 2"
  # definition
  test_parser "(= a 1)" "a = 1"
  test_parser "(= f (=> a a))" "f a = a"
  test_parser "(= a (+ 1 2))" "a = 1 + 2"
  test_parser "(= f (=> a a))" "f a =\n  a"
  test_parser "(= f (=> a (a; b)))" "f a =\n  a\n  b"
  test_parser "(= f (=> a ((= b 1); (+ a b))))" "f a =\n  b = 1\n  a + b"
  # property access
  test_parser "(. a b)" "a.b"
  test_parser "((. a b) c)" "a.b c"
  test_parser "(. list a)" "[].a"
  test_parser "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
  # single operator
  test_parser "(! true)" "!true"
  # binary operators
  test_parser "(+ 1 2)" "1 + 2"
  test_parser "(+ 1 (+ 2 3))" "1 + 2 + 3"
  test_parser "(+ (* 1 2) 3)" "1 * 2 + 3"
  test_parser "(!= 1 1)" "1 != 1"
  test_parser "(+= a 1)" "a += 1"
  test_parser "(+= a (+ 1 2))" "a += 1 + 2"
  # parentheses
  test_parser "1" "(1)"
  test_parser "(f 1)" "(f 1)"
  test_parser "(+ (+ 1 2) 3)" "(1 + 2) + 3"
  test_parser "(* 1 (+ 2 3))" "1 * (2 + 3)"
  test_parser "(* (+ 1 2) 3)" "(1 + 2) * 3"
  # function call
  test_parser "(( f)" "f()"
  test_parser "(f 1)" "f(1)"
  test_parser "(f (+ 1 2))" "f(1 + 2)"
  # method call
  test_parser "(. f m)" "f.m"
  test_parser "(. f 1)" "f.1"
  test_parser "(( (. f m))" "f.m()"
  test_parser "((. f m) a)" "f.m(a)"
  test_parser "((. f m) a b)" "f.m(a b)"
  # index access
  test_parser "(__index x 1)" "x[1]"
  test_parser "(__index x 1 2)" "x[1 2]"
  # steps
  test_parser "(a; b)" "a\nb"
  test_parser "((a b); c)" "a b\nc"
  test_parser "(a; (b c))" "a\nb c"
  # block
  test_parser "(a b)" "a: b"
  test_parser "(a (b c))" "a: b c"
  test_parser "(a b c)" "a b: c"
  test_parser "(a b (c d))" "a b: c d"
  # indent
  test_parser "(a b)"               "a:\n  b"
  test_parser "((a b); c)"          "a:\n  b\nc"
  test_parser "(a (b; c))"          "a:\n  b\n  c"
  test_parser "(a (b c))"           "a:\n  b:\n    c"
  test_parser "(a b c)"             "a b:\n  c"
  test_parser "(a b (c d))"         "a b:\n  c d"
  test_parser "(a b (c; d))"        "a b:\n  c\n  d"
  test_parser "(a b ((c d); e))"    "a b:\n  c d\n  e"
  test_parser "(a b (c d e))"       "a b:\n  c d:\n  e"
  test_parser "(a b (c d (e f)))"   "a b:\n  c d:\n  e f"
  # comment
  test_parser "(= a 1)" "#comment\na = 1 # comment\n#comment"
  test_parser "(a (b; c))" "a:\n  #comment\n  b\n  #comment\n  c\n  # comment"
  # combinations
  test_parser "(! (a b))" "!a(b)"
  test_parser "(+ (a b) c)" "a(b) + c"
  test_parser "(. (__index a b) c)" "a[b].c"
  test_parser "((. (__index a b) c) d)" "a[b].c(d)"
  # combinations
  test_parser "(! (a b))" "!a(b)"
  test_parser "(+ (a b) c)" "a(b) + c"
  # edge case
  test_parser "1" "1\n"
  test_parser "()" " "
  test_parser "()" "\n"
  log "ok"
