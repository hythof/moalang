(record Token
  code   string
  offset int
  args   list[Token])

(record Type
  name   string
  params list[Type]
  props  dict[string Type])

(def tshow(t)
  (++ t.name (iif (== t.params.size 0) "" (++ "[" t.params.map(tshow).join(" ") "]"))))

(def parse(source)
  (var offset 0)
  (let tempty (Token "" 0 list()))
  (def tlist(a) (Token "" 0 a))
  (let reg regexp("([+\\-*\\/%|&<>!=]+|[(){};.]|[A-Za-z_][0-9A-Za-z_]*|[0-9]+(?:\\.[0-9]+)?|\".*?(?<!\\\\)\"|(?:#[^\\n]*|\\s+))" "s"))
  (let tokens source.split(reg).fmap((fn code do(
    (+= offset code.size)
    (iif
      regexp("^[^#\\s]").match(code) Token(code offset (list))
      (list))
  ))))
  (var pos 0)
  (def next (+= pos 1) tokens[(- pos 1)])
  (def back(t) (-= pos 1) t)
  (def many_(f acc)
    (iif
      (>= pos tokens.size) acc
      (fn(t
        (iif
          (== t tempty) acc
          (many f (++ acc (list t)))))
        (f (next)))))
  (def many(f)
    (var a (list))
    (while (< pos tokens.size)
      (let t (f (next)))
      (if (== t tempty) break)
      a.push(t))
    tlist(a))
  (def parseList
    (many (fn t (iif (&& (!= t.code ")") (!= t.code "]")) (parseUnit t) tempty))))
  (def parseUnit(t)
    (def suffix(t)
      (if (<= tokens.size pos) (return t))
      (let tt (next))
      (let near (== tokens[(- pos 2)].offset (- tt.offset tt.code.size)))
      (iif (== tt.code ".") (suffix (tlist (list tt t (next))))
        (&& near (== tt.code "(")) (suffix (tlist (++ (list t) (parseList).args)))
        (&& near (== tt.code "[")) (suffix (tlist (++ (list tt t) (parseList).args)))
        (back t)))
    (iif
      (== t.code "(") (suffix (parseList))
      (== t.code "!") (suffix (tlist (list t (parseUnit (next)))))
      (suffix t)))
  (many parseUnit).args)

(def infer(root)
  (let tv1     (Type "1"      (list) (dict)))
  (def tf(a)   (Type ""       a      (dict)))
  (def tor(a)  (Type "__or"   a      (dict)))
  (let tvoid   (Type "void"   (list) (dict)))
  (let tint    (Type "int"    (list) (dict)))
  (let tfloat  (Type "float " (list) (dict)))
  (let tstring (Type "string" (list) (dict)))
  (let tbool   (Type "bool"   (list) (dict)))
  (let tserial (tor (list tint tfloat tstring tbool)))
  (let embedded dict(
    "io" Type("io" (list) dict("puts" tf((list tserial tvoid))))
    "assert" (tf (list tv1 tv1 tvoid))
    "!"      (tf (list tbool tbool))
    "||"     (tf (list tbool tbool))
    "&&"     (tf (list tbool tbool))
    "true"   tbool
    "false"  tbool
  ))
  (def inferTop(node tenv)
    (iif
      tenv.has(node) tenv.get(node)
      tenv.set(node inferWith(node tenv))))
  (def inferWith(node tenv)
    (def touch(x) inferTop(x tenv))
    (def get(token)
      (let key token.code)
      (iif
        regexp("^[0-9]+\.").match(key) tfloat
        regexp("^[0-9]").match(key)    tint
        key.starts(34.char)            tstring
        tenv.has(key)                  tenv[key]
        embedded.has(key)              embedded[key]
        (throw (++ "key `" key "` not found"))))
    (def put(key type)
      tenv.set(key type))
    (def unify(a b)
      # TODO implement
      b)
    (def call(f args)
      args.mapi(fn(a i (unify f.params[i] a))).at((-1))
      f.params.at((-1)))
    (iif
      (== node.args.size 0) get(node)
      (== node.args[0].code "def") put(node.args[1] node.args.slice(2).map(touch).at((-1)))
      (== node.args[0].code ".") touch(node.args[1]).props[node.args[2].code]
      (call (touch node.args[0]) node.args.slice(1).map(touch))))
  (let troot dict())
  root.map(fn(node (inferTop node troot)))
  troot)

(def compileToJs(source)
  (let nodes (parse source))
  (let tenv (infer nodes))
  (def isFn(t)
    (== t.name ""))
  (def method(t f)
    (++ "__" t.name (iif (== t.params.size 0) "" (++ "__" t.params.map(tshow).join("_"))) "_" f.code))
  (def property(node o f)
    (iif (isFn tenv[node]) (method tenv[o] f)
      (++ o.code "." f.code)))
  (def apply(node)
    (let head node.args[0])
    (let tail node.args.slice(1))
    (def isOp2(op)
      (&& (!= op "!") (regexp "^[+\\-*\\/%|&<>!=^]").match(op)))
    (def op2(op l r)
      (++ l " " op " " r))
    (iif
      (== head.code "def") (++ "const " tail[0].code " = (" ") => " gen(tail.at((-1))))
      (== head.code ".") (property node tail[0] tail[1])
      (isOp2 head.code) (op2 head.code gen(tail[0]) gen(tail[1]))
      (++ gen(head) "(" tail.map(gen).join(", ") ")")))
  (def gen(node)
    (iif
      (== node.args.size 0) node.code
      (apply node)))
  nodes.map(gen).join("\n"))
