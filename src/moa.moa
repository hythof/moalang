# data type
token:
  tag string
  code string
ast|
  aint: value token
  aid: name token
  afunc: name token, args []token, body ast
  acall: target ast, argv []token
  aop2: op token, lhs ast, rhs ast

# helper
many_acc f acc = f.then(c => many_acc(f acc.concat([c]))).alt(acc)
many f = many_acc(f [])
many1 f =
  c <- f
  cs <- many(f)
  [c].concat(cs)

# main process
tokenize src =
  pos := 0
  satisfy f =
    c <- src.at(pos)
    guard(f(c))
    pos += 1
    c
  many1t tag f = many1(f).then(cs => token(tag cs.join("")))
  read_int = many1t("int" satisfy(c => ("0" <= c) && (c <= "9")))
  read_id = many1t("id" satisfy(c => ("a" <= c) && (c <= "z")))
  read_spaces = many1t("spaces" satisfy(c => " \n#".includes(c)))
  read_sym = many1t("sym" satisfy(c => "+-*/%=><&|:()[].".includes(c)))
  read_top = read_int.alt(read_id).alt(read_spaces).alt(read_sym)
  tokens <- many(read_top)
  assert(pos == src.count)
  tokens.filter(t => t.tag != "spaces")
parse tokens =
  pos := 0
  consume f =
    t <- tokens.at(pos)
    guard(f(t))
    pos += 1
    t
  look =
    tokens.at(pos).alt(token("eot" ""))
  consume_id =
    consume(t => t.tag == "id")
  consume_sym s =
    consume(t => t.code == s)
  consume_syms s =
    consume(t => s.includes(t.code))
  consume_between l r c =
    consume_sym(l)
    ret <- c
    consume_sym(r)
    ret
  parse_func =
    name <- consume_id
    args <- many(consume_id)
    consume_sym("=")
    body <- parse_exp
    afunc(name args body)
  parse_unit =
    parse_parenthesis =
      consume_between("(" ")" parse_exp)
    parse_int =
      consume(t => t.tag == "int").then(aint)
    parse_id =
      consume(t => t.tag == "id").then(aid)
    parse_call target =
      consume_sym("(")
      argv <- many(parse_exp)
      consume_sym(")")
      acall(target argv)
    val <- parse_parenthesis.alt(parse_int).alt(parse_id)
    parse_call(val).alt(val)
  parse_exp =
    token <- parse_unit
    parse_op2 =
      op <- consume_syms("+ - * / > < >= <= == != || && .".split(" "))
      rhs <- parse_exp
      aop2(op token rhs)
    parse_op2.alt(token)
  many(parse_func)
generate defines =
  gen a = match(a
    aint  a.value.code
    aid   a.name.code
    afunc ("const " + a.name.code + " = (" + a.args.map(a => a.code).join(",") + ") => " + gen(a.body))
    acall (gen(a.target) + "(" + a.argv.map(gen).join(",") + ")")
    aop2  (gen(a.lhs) + a.op.code + gen(a.rhs)))
  defines.map(gen).join("\n")
main =
  #src <- io.reads
  src = "main = console.log(1 + 2)"
  tokens <- tokenize(src)
  defines <- parse(tokens)
  js <- generate(defines)
  io.print(js+"\nmain()")
