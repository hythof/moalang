def compile src:
  let tokens:
    let reg ```([():\\[\\].]|[-+*/%&|!=><]+|""".*"""|`{3}.*`{3}|"[^"]*?"|`[^`]*?`|[ \n]+|[a-zA-Z0-9_,]+(?:\\(\\)|\\(?)|#.+)```
    src.rsplit(reg).map(t => t.rsub("^ +" "").rsub("#.*" "").trim()).filter(x => x)
  def is_op2 x: '+-*/%&|!=<>'.includes(x[0])
  def parse:
    let pos 0
    def next o:
      pos += 1
      o
    def until a f:
      let a []
      if pos < tokens.length && f(tokens.at(pos)):
        a.push consume()
      a
    [["def" "main" ["do" ["let" "a" "1"] ["+" "a" "2"]]]]
  def gen node:
    def exps a:
      let code a.map(e,i => case(i == a.size - 1 "return " "") + gen(e)).join("\n  ")
      `(() => {\n  ${code}\n})()`
    def apply head tail:
      def _def name args body: `const ${name} = (${args}) => ${body}`
      case(tail.length == 0 gen(head)
        head == "def" _def(tail.at(0) tail.slice(1 (-1)) gen(tail.at((-1))))
        head == "do" case(tail.length == 1 gen(tail.at(0)) exps(tail))
        head == "let" `let ${tail.at(0)} = ${gen(tail.slice(1))}`
        is_op2(head) `${gen(tail.at(0))} + ${gen(tail.at(1))}`
        `${gen(head)}(${tail.map(gen).join(', ')})`)
    case Array.isArray(node) && node.size apply(node.at(0) node.slice(1)) node
  parse().map(gen).join("\n")

def test t:
  def exp expected e: t.eq expected eval(compile(`def main:\n  ${e}`) + "\nmain()")
  exp 3 `1 + 2`

#    const until = f => {
#      const a = []
#      while (pos < tokens.length && f(tokens[pos])) {
#        a.push(consume())
#      }
#      return a
#    }
#    const reads = f => until(t => until(t => t[0] === '\n') && f(t))
#    const right = () => until(t => t[0] !== '\n')
#    const sepby = f => [right()].concat(pos < tokens.length && f(tokens[pos]) ? sepby(next(f)) : [])
#    const consume = () => {
#      const priorities = '|| && == != > >= < <= * / % + -'.split(' ')
#      const priority = op => priorities.findIndex(x => x === op)
#      const op2 = (op, l, r) => Array.isArray(r) && is_op2(r[0]) && priority(op) > priority(r[0]) ? [r[0], [op, l, r[1]], r[2]] : [op, l, r]
#      const t = tokens[pos++]
#      const node =
#        t === '(' ? next(reads(t => t !== ')')) :
#        t.endsWith('(') ? [t.slice(0, -1)].concat(next(reads(t => t !== ')'))) :
#        t === '[' ? ['array'].concat(next(reads(t => t !== ']'))) :
#        t === ':' && tokens[pos][0] === '\n' ? ['do'].concat(top(tokens[pos++])) :
#        t === ':' ? ['do'].concat([right()]) :
#        t
#      const predict = node => {
#        const tt = tokens[pos] || ''
#        const dot = t => t.endsWith('(') ? [['.', node, t.slice(0, -1)]].concat(next(reads(t => t !== ')'))) : ['.', node, t]
#        return is_op2(tt) ? predict(op2(tokens[pos++], node, consume())) :
#          tt === '.' ? ++pos && predict(dot(tokens[pos++])) :
#          node
#      }
#      return predict(node)
#    }
#    const top = br => sepby(t => t === br)
#    return top('\n')
