def main:
  case io.argv.get(0).or(""):
    "": repl()
    "build": build()
    "test": test()
    "format": format()
    _: help()

def build:
  let source io.shell("find . -name *.moa | xargs cat").result
  let nodes parse(source)
  log nodes
  log "(build under developing)"

def repl:
  log "(repl under developing)"

def test:
  log "(test under developing)"

def format:
  log "(format under developing)"

def help:
  log "Usage:
  moa <command> [arguments]

The commands are:
  moa                    # launch REPL
  moa build [option] ... # compile
  moa test [path] ...    # run tests
  moa format [path] ...  # format code"

record Token:
  code   string
  offset int
  lineid int
  indent int
  args   list[Token]

def parse source:
  var offset 0
  var lineid 1
  var indent 0
  def tmap code:
    offset += code.size
    lineid += iif(code.starts("\"") 0 code.split("\n").size - 1)
    lineid + iif(code == ";" 1 0)
    indent = iif(code.starts("\"") && code.has("\n") code.split("\n")[-1].size indent)
    let enabled code != ";" && !regexp("^\s*#").match(code) && code.trim.size > 0
    iif enabled list(Token(code lineid offset indent)) list()
  let reg regexp("([+\\-*\\/%|&<>!=]+|[(){};.]|[A-Za-z_][0-9A-Za-z_]*|[0-9]+(?:\\.[0-9]+)?|\".*?(?<!\\\\)\"|(?:#[^\\n]*|\\s+))" "s")
  let tokens reg.split(source).fmap(tmap)
  var pos 0
  let op2s "|| && = == != < <= > >= ++ + - | & ^ ~ * / % ^ **".split(" ") # low...high, other operators are lowest
  let ops list("!"  "=>") ++ op2s
  def back t:
    pos -= 1
    t
  def forward:
    let t tokens[pos]
    pos += 1
    t
  def tlist a:
    Token "" 0 0 0 a
  def tcode code:
    Token code 0 0 0 list()
  def many f:
    var a list()
    while pos < tokens.size:
      let x f(tokens[pos])
      iif x.size == 0 break a.push(f(tokens[pos]))
      pos += 1
    a
  def until code:
    let a many(unit t => t.code != code)
    pos += 1
    a
  def priority t:
    op2s.index op => op == t.code
  def isOp t:
    t.code && ops.has(t.code)
  def isOp2 t:
    t.code && op2s.includes(t.code) || op2s.find(op => t.code == op + '=')
  def reorder op l r:
    iif:
      isOp2(r[0]) && priority(r[0]) < priority(op): list(r[0] list(op l r[1]) r[2])
      list(op l r)
  def suffix x:
    if pos >= tokens.length:
      return x
    let t tokens[pos]
    pos += 1
    let near t.offset - t.code.size == tokens[pos-2].offset
    iif:
      near && t.code == '(': suffix list(x) ++ until(')')
      near && t.code == '[': suffix list(t x) ++ until(']')
      near && t.code == '.': suffix list(t x forward())
      t.code == '=>'       : arrow(x, t, tokens[pos].indent)
      isOp2(t)             : reorder(t, x, unit(forward()))
      back(x)
  def parenthesis a:
    iif:
      isOp(a[0])                     : a
      a.length == 1 && isOp(a[0][0]) : a[0]
      a.length == 1                  : a
      throw "TooManyInParenthesis"
  def arrow x t indent:
    iif:
      tokens[pos].lineid == t.lineid: list(t x unit(forward()))
      list(t, x, list(tcode(':')) ++ many(t => back(line(t.lineid)) t => t.indent == indent))
  def block t indent:
    iif tokens[pos].lineid == t.lineid:
      line t.lineid
      list(t) ++ many t =>
        iif t.indent != indent:
          list()
          back(line(t.lineid))
  def unit t:
    iif:
      t.code == "!": list t suffix(unit(forward()))
      t.code == "(": suffix parenthesis(until(")"))
      t.code == ":": block t tokens[pos].indent
      suffix(t)
  def line lineid:
    def unlist a:
      iif a.size == 1:
        a[0]
        a
    unlist many(unit t => t.lineid == lineid && t.code != ")")
  many t => back(line(t.lineid))
