help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source = "const main = io => log(io)"

class token:
  text string
  indent int
  lineno int
  column int

union type:
  tundef
  tlambda list[type]
  tname:
    name string
    params list[type]
  tref:
    id int
    type type

union ast:
  aid:
    token token
    type type
  acall:
    head ast
    argv list[ast]
  alambda:
    args list[ast]
    body ast
  alet:
    id token
    body ast

union input:
  iunit token
  icall list[input]
  istatement list[input]

show_type t = match t:
  _.tundef : "?"
  x.tlambda: "(" ++ x.map(show_type).join(" ") ++ ")"
  x.tname  :
    guard x.params.size == 0: x.name
    x.name ++ "[" ++ x.params.map(show_type).join(" ") ++ "]"
  x.tref   :
    match x.type:
      _.tundef: x.id.string
      t: show_type t

parse source =
  tokens =
    regexp = r"((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\n]+(?:#[^\n]*|[ \t\n]+)*|\"[^]*?(?<!\\)\"|[A-Za-z0-9_]+|#[^\n]*)"
    indent = 0
    lineno = 1
    column = 1
    source.rsplit(regexp).fmap text =>
      guard text == "": []
      guard text.has("\n"):
        indent := text.split("\n")[-1].size
        lineno += text.split("\n").size - 1
        column := indent
        []
      guard text.match(r"^[ \t#]"): []
      t = token text indent lineno column
      column += text.size
      t
  guard tokens.size == 0: istatement []
  pos = 0
  new_iunit s = iunit token(s 0 0 0)
  end_by forward check =
    loop a =
      guard pos >= tokens.size: a
      guard check(tokens[pos]): a
      loop a ++ [forward()]
    loop []
  parse_unit = () =>
    until end = end_by parse_exp t =>
      guard t.text == end:
        pos += 1
        true
      false
    consume = () =>
      t = tokens[pos]
      pos += 1
      match t.text:
        "(": icall until(")")
        "[": icall [iunit(t)] ++ until("]")
        ":": parse_block()
        _: iunit t
    suffix x =
      guard pos >= tokens.size: x
      t = tokens[pos]
      match t.text:
        ".":
          pos += 2
          suffix icall([iunit(t) x iunit(tokens[pos - 1])])
        "(":
          pos += 1
          argv = until(")")
          guard argv.size == 0: suffix icall([new_iunit("__call") x])
          suffix icall([x] ++ argv)
        "[":
          pos += 1
          suffix icall([new_iunit("__index") x until("]")])
        _: x
    suffix consume()
  parse_exp = () =>
    lhs = parse_unit()
    guard pos >= tokens.size: lhs
    guard lhs == iunit("!"): icall [lhs parse_unit()]
    lop = tokens[pos]
    op2s = ", * ** / // % + ++ - >> << ^ & | := += -= *= /= %= **= < <= > >= == != === !== <=> && || =>".split " "
    guard op2s.has(lop.text):
      pos += 1
      rhs_first_text = tokens[pos].text
      rhs = parse_exp()
      guard rhs_first_text != "(" && rhs === icall:
        rop = rhs[0]
        guard rop === iunit && op2s.index(lop.text) < op2s.index(rop.text):
          icall [rhs[0] icall([iunit(lop) lhs rhs[1]]) rhs[2]] # "1 * 2 + 3" -> (* 1 (+ 2 3)) -> (+ (* 1 2) 3)
        icall [iunit(lop) lhs icall(rhs)]
      icall [iunit(lop) lhs rhs]
    lhs
  parse_block = () =>
    guard tokens[pos - 1].indent < tokens[pos].indent: parse_statement()
    parse_line()
  parse_line = () =>
    lineno_ = tokens[pos].lineno
    loop a =
      guard pos >= tokens.size || tokens[pos].lineno != lineno_:
        guard a.size == 1: a[0]
        icall a
      guard tokens[pos].text == "=":
        define_iunit = iunit tokens[pos]
        pos += 1
        guard a.size == 1: icall [define_iunit a[0] parse_block()]
        lambda = icall [new_iunit("=>") icall(a.slice(1)) parse_block()]
        icall [define_iunit a[0] lambda]
      loop a ++ [parse_exp()]
    loop []
  parse_statement = () =>
    current_indent = tokens[pos].indent
    istatement end_by(parse_line t => t.indent != current_indent)
  parse_statement()

infer input =
  tint = tname "int" []
  tstring = tname "string" []
  infer_unit_type s =
    guard s.match(r"^[0-9]+$"): tint
    guard s.starts("\""): tstring
    tundef
  match input:
    x.iunit:
      x.type := infer_unit_type x.text
    x.icall:
      tundef
    x.istatement:
      guard x.size == 1: infer x[0]
      tundef

test t "parser":
  stringify x =
    join a glue =
      guard a.size == 1: stringify a[0]
      "(" ++ a.map(stringify).join(glue) ++ ")"
    match x:
      x.iunit     : x.text
      x.icall     : join x " "
      x.istatement: join x "; "
  i1 = iunit token("1" 0 0 0)
  test_stringify expectation input = t.eq expectation stringify(input)
  test_stringify "1"      i1
  test_stringify "(1 1)"  icall([i1 i1])
  test_stringify "(1; 1)" istatement([i1 i1])

  test_parser expectation source = t.eq expectation stringify(parse(source)) source
  # primitives
  test_parser "1" "1"
  test_parser "1.1" "1.1"
  test_parser "id" "id"
  test_parser "\"hi\"" "\"hi\""
  test_parser "\"\\t\"" "\"\\t\""
  test_parser "true" "true"
  # container
  test_parser "[" "[]"
  test_parser "([ 1 2)" "[1 2]"
  test_parser "(=> a a)" "a => a"
  test_parser "(=> (, a b) a)" "a,b => a"
  test_parser "(=> p (+ 1 2))" "p => 1 + 2"
  # definition
  test_parser "(= a 1)" "a = 1"
  test_parser "(= f (=> a a))" "f a = a"
  test_parser "(= a (+ 1 2))" "a = 1 + 2"
  test_parser "(= f (=> a a))" "f a =\n  a"
  test_parser "(= f (=> a (a; b)))" "f a =\n  a\n  b"
  test_parser "(= f (=> a ((= b 1); (+ a b))))" "f a =\n  b = 1\n  a + b"
  # property access
  test_parser "(. a b)" "a.b"
  test_parser "((. a b) c)" "a.b c"
  test_parser "(. [ a)" "[].a"
  test_parser "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
  # single operator
  test_parser "(! true)" "!true"
  # binary operators
  test_parser "(+ 1 2)" "1 + 2"
  test_parser "(+ 1 (+ 2 3))" "1 + 2 + 3"
  test_parser "(+ (* 1 2) 3)" "1 * 2 + 3"
  test_parser "(!= 1 1)" "1 != 1"
  test_parser "(+= a 1)" "a += 1"
  test_parser "(+= a (+ 1 2))" "a += 1 + 2"
  # parentheses
  test_parser "1" "(1)"
  test_parser "(f 1)" "(f 1)"
  test_parser "(+ (+ 1 2) 3)" "(1 + 2) + 3"
  test_parser "(* 1 (+ 2 3))" "1 * (2 + 3)"
  test_parser "(* (+ 1 2) 3)" "(1 + 2) * 3"
  # function call
  test_parser "(__call f)" "f()"
  test_parser "(f 1)" "f(1)"
  test_parser "(f (+ 1 2))" "f(1 + 2)"
  # method call
  test_parser "(. f m)" "f.m"
  test_parser "(. f 1)" "f.1"
  test_parser "(__call (. f m))" "f.m()"
  test_parser "((. f m) a)" "f.m(a)"
  test_parser "((. f m) a b)" "f.m(a b)"
  # index access
  test_parser "(__index x 1)" "x[1]"
  test_parser "(__index x 1 2)" "x[1 2]"
  # steps
  test_parser "(a; b)" "a\nb"
  test_parser "((a b); c)" "a b\nc"
  test_parser "(a; (b c))" "a\nb c"
  # block
  test_parser "(a b)" "a: b"
  test_parser "(a (b c))" "a: b c"
  test_parser "(a b c)" "a b: c"
  test_parser "(a b (c d))" "a b: c d"
  # indent
  test_parser "(a b)"               "a:\n  b"
  test_parser "((a b); c)"          "a:\n  b\nc"
  test_parser "(a (b; c))"          "a:\n  b\n  c"
  test_parser "(a (b c))"           "a:\n  b:\n    c"
  test_parser "(a b c)"             "a b:\n  c"
  test_parser "(a b (c d))"         "a b:\n  c d"
  test_parser "(a b (c; d))"        "a b:\n  c\n  d"
  test_parser "(a b ((c d); e))"    "a b:\n  c d\n  e"
  test_parser "(a b (c d e))"       "a b:\n  c d:\n  e"
  test_parser "(a b (c d (e f)))"   "a b:\n  c d:\n  e f"
  # comment
  test_parser "(= a 1)" "#comment\na = 1 # comment\n#comment"
  test_parser "(a (b; c))" "a:\n  #comment\n  b\n  #comment\n  c\n  # comment"
  # combinations
  test_parser "(! (a b))" "!a(b)"
  test_parser "(+ (a b) c)" "a(b) + c"
  test_parser "(. (__index a b) c)" "a[b].c"
  test_parser "((. (__index a b) c) d)" "a[b].c(d)"
  # combinations
  test_parser "(! (a b))" "!a(b)"
  test_parser "(+ (a b) c)" "a(b) + c"
  # edge case
  test_parser "1" "1\n"
  test_parser "()" " "
  test_parser "()" "\n"

  test_show expectation type = t.eq expectation show_type(type)
  test_show "?" tundef
  test_show "(? ?)" tlambda([tundef tundef])
  test_show "a" tname("a" [])
  test_show "a[b c]" tname("a" [tname("b" []) tname("c" [])])
  test_show "1" tref(1 tundef)
  test_show "a" tref(1 tname("a" []))

  #test_infer expectation source = t.eq expectation show_type(infer(parse(source))) source
  #test_infer "int" "1"
  #test_infer "string" "\"s\""
  log "ok"
