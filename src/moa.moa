help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

def main io:
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

def repl io:
  io.puts "repl"

def compile_to_js source:
  "const main = io => log(io)"

class token:
  text string
  indent int
  lineno int
  column int

union type:
  tid int
  tlambda list[type]
  tname:
    name string
    generics list[type]
    fields dict[string type]

union ast:
  aid:
    token token
  aconst:
    token token
  acall:
    head ast
    argv list[ast]
  alambda:
    args list[token]
    body ast
  alet:
    id token
    body ast
  astatement:
    lines list[ast]

def show_type t:
  match t:
    x.tlambda: "(" ++ x.map(show_type).join(" ") ++ ")"
    x.tname  :
      guard x.generics.size == 0: x.name
      x.name ++ "[" ++ x.generics.map(show_type).join(" ") ++ "]"
    x.tid    : x.string

def parse source:
  tokens =
    regexp = r"((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\n]+(?:#[^\n]*|[ \t\n]+)*|\"[^]*?(?<!\\)\"|[A-Za-z0-9_]+|#[^\n]*)"
    indent = 0
    lineno = 1
    column = 1
    source.rsplit(regexp).fmap text =>
      guard text == "": []
      guard text.has("\n"):
        indent := text.split("\n")[-1].size
        lineno += text.split("\n").size - 1
        column := indent
        []
      guard text.match(r"^[ \t#]"): []
      t = token text indent lineno column
      column += text.size
      t
  def alias t text:
    aid token(text t.indent t.lineno t.column)
  guard tokens.size == 0: astatement []
  pos = 0
  def end_by forward check:
    def loop a:
      guard pos >= tokens.size: a
      guard check(tokens[pos]): a
      loop a ++ [forward()]
    loop []
  def until end:
    end_by parse_exp t =>
      guard t.text == end:
        pos += 1
        true
      false
  def parse_unit:
    def consume:
      t = tokens[pos]
      pos += 1
      match t.text:
        "(": until(")")[0]
        "[": acall(alias(t "list") until("]"))
        ":": parse_block()
        text:
          guard text.match(r"^[A-Za-z_]"): aid t
          aconst t
    def suffix x:
      guard pos >= tokens.size: x
      t = tokens[pos]
      match t.text:
        ".":
          pos += 2
          suffix acall(aid(t) [x aid(tokens[pos - 1])])
        ",":
          remain = end_by consume t =>
            guard t.text == ",":
              pos += 1
              false
            true
          guard pos < tokens.size && tokens[pos].text == "=>": alambda [t] ++ remain parse_exp()
          suffix acall(alias(t "tuple") [x] ++ remain)
        "(":
          pos += 1
          suffix acall(x until(")"))
        "[":
          pos += 1
          suffix acall(alias(t "__index") [x] ++ until("]"))
        _: x
    suffix consume()
  def parse_exp:
    lhs = parse_unit()
    guard pos >= tokens.size: lhs
    guard lhs === aid && lhs.token.text == "!": acall aid(lhs.token) [parse_unit()]
    lop_token = tokens[pos]
    op2s = ", * ** / // % + ++ - >> << ^ & | := += -= *= /= %= **= < <= > >= == != === !== <=> && || =".split " "
    guard op2s.has(lop_token.text):
      pos += 1
      rhs_first_text = tokens[pos].text
      rhs = parse_exp()
      rcall = rhs
      guard rhs_first_text != "(" && rcall === acall && rcall.argv.size == 2:
        rop = rcall.head
        guard rop === aid && op2s.has(rop.token.text) && op2s.index(lop_token.text) < op2s.index(rop.token.text):
          acall rcall.head [acall(aid(lop_token) [lhs rcall.argv[0]]) rcall.argv[1]] # "1 * 2 + 3" -> (* 1 (+ 2 3)) -> (+ (* 1 2) 3)
        acall aid(lop_token) [lhs rhs]
      acall aid(lop_token) [lhs rhs]
    guard lop_token.text == "=>" && lhs === aid:
      pos += 1
      alambda [lhs.token] parse_exp()
    lhs
  def parse_block:
    guard tokens[pos - 1].indent < tokens[pos].indent: parse_statement()
    parse_line()
  def parse_line:
    first_pos = pos
    first_token = tokens[pos]
    guard first_token.text == "def":
      pos += 1
      name = tokens[pos]
      def take_args a:
        pos += 1
        guard pos >= tokens.size: a
        guard tokens[pos].text == ":": a
        take_args a ++ tokens[pos]
      args = take_args []
      alet name alambda(args parse_exp())
    guard pos + 1 < tokens.size && tokens[pos+1].text == "=":
      pos += 2
      alet first_token parse_exp()
    def loop a:
      guard pos >= tokens.size || tokens[pos].lineno != first_token.lineno:
        guard a.size == 1: a[0]
        acall a[0] a.slice(1)
      loop a ++ [parse_exp()]
    loop []
  def parse_statement:
    current_indent = tokens[pos].indent
    astatement end_by(parse_line t => t.indent != current_indent)
  parse_statement()

def infer ast:
  tbool = tname "bool" [] dict()
  tint = tname "int" [] dict()
  tfloat = tname "float" [] dict()
  tstring = tname "string" [] dict()
  id = 0
  new_tid = () => tid(id+=1)
  tzero = tid 0
  def unify a b:
    tzero
##union type:
##  tid int
##  tlambda list[type]
##  tname:
##    name string
##    generics list[type]
##    fields dict[string type]
#    a = prune a
#    b = prune b
#    guard a == tid && b == tid && a.id == b.id:
# 94   const unify = (a, b) => {
# 95     a = prune(a)
# 96     b = prune(b)
# 97     if (a.var) {
# 98       if (a.name !== b.name) {
# 99         a.instance = b
#100       }
#101     } else if (b.var) {
#102       unify(b, a)
#103     } else {
#104       if (a.name !== b.name) { fail(`type miss match`, {a,b}) }
#105       if (a.types || b.types) {
#106         if (a.types.length !== b.types.length) { fail('types miss match', {a,b}) } // TODO
#107         a.types.map((t,i) => unify(t, b.types[i]))
#108       }
#109     }
#110   }
  def inf_with ast env:
    def inf x:
      inf_with x env
    def inf_const s:
      guard s == "true" || s == "false": tbool
      guard s.match(r"^[0-9]+\.[0-9]+$"): tfloat
      guard s.match(r"^[0-9]+$"): tint
      guard s.match(r"^[A-Za-z_]"): env[s]
      guard s.starts("\""): tstring
      error s
    match ast:
      x.aid   : env[x.token.text]
      x.aconst: inf_const x.token.text
      x.acall : unify inf(x.head) x.argv.map(inf)
      x.alambda:
        argst = x.args.map(t => t.text, new_tid())
        new_env = env ++ argst.dict()
        tlambda argst.map(x => x[1]) ++ [inf_with(x.body new_env)]
      x.astatement:
        x.lines.map(inf)[-1]
  inf_with ast dict(
    "list" tlambda(tzero tzero)
    "true" tbool
    "false" tbool)

test t "parser":
  def stringify x:
    match x:
      x.aid        : x.token.text
      x.aconst     : x.token.text
      x.acall      : stringify(x.head) ++ "(" ++ x.argv.map(stringify).join(" ") ++ ")"
      x.alambda    : "(" ++ x.args.map(t => t.text).join(",") + " => " + stringify(x.body) ++ ")"
      x.alet       : x.id.text ++ " = " ++ stringify(x.body)
      x.astatement : x.lines.map(stringify).join("; ")
  def test_stringify expectation input:
    t.eq expectation stringify(input)
  x = aid token("x" 0 0 0)
  test_stringify "x"        x
  test_stringify "x(x)"     acall(x [x])
  test_stringify "(x => x)" alambda([token("x" 0 0 0)] x)
  test_stringify "y = x"    alet(token("y" 0 0 0) x)
  test_stringify "x; x"     astatement([x x])

  def test_parser expectation source:
    t.eq expectation stringify(parse(source)) source
  test_parser "(a => a)" "a => a"

  # primitives
  test_parser "1" "1"
  test_parser "1.1" "1.1"
  test_parser "id" "id"
  test_parser "\"hi\"" "\"hi\""
  test_parser "\"\\t\"" "\"\\t\""
  test_parser "true" "true"
  test_parser "tuple(a b)" "a,b"
  test_parser "tuple(a b c)" "a,b,c"
  test_parser "(a => a)" "a => a"
  # container
  test_parser "list()" "[]"
  test_parser "list(1 2)" "[1 2]"
  # property access
  test_parser ".(a b)" "a.b"
  test_parser ".(a b)(c)" "a.b c"
  test_parser ".(list() a)" "[].a"
  test_parser "(p => +(.(p x) .(p y)))" "p => p.x + p.y"
  # single operator
  test_parser "!(true)" "!true"
  # binary operators
  test_parser "+(1 2)" "1 + 2"
  test_parser "+(1 +(2 3))" "1 + 2 + 3"
  test_parser "+(*(1 2) 3)" "1 * 2 + 3"
  test_parser "!=(1 1)" "1 != 1"
  test_parser "+=(a 1)" "a += 1"
  test_parser "+=(a +(1 2))" "a += 1 + 2"
  # parentheses
  test_parser "1" "(1)"
  test_parser "+(+(1 2) 3)" "(1 + 2) + 3"
  test_parser "*(1 +(2 3))" "1 * (2 + 3)"
  test_parser "*(+(1 2) 3)" "(1 + 2) * 3"
  # definition
  test_parser "a = 1" "a = 1"
  test_parser "f = (a => a)" "def f a: a"
  test_parser "a = +(1 2)" "a = 1 + 2"
  test_parser "f = (a => a)" "def f a:\n  a"
  test_parser "f = (a => a; b)" "def f a:\n  a\n  b"
  test_parser "f = (a => b = 1; +(a b))" "def f a:\n  b = 1\n  a + b"
  # function call
  test_parser "f()" "f()"
  test_parser "f(1)" "f(1)"
  test_parser "f(+(1 2))" "f(1 + 2)"
  # method call
  test_parser ".(f m)" "f.m"
  test_parser ".(f 1)" "f.1"
  test_parser ".(f m)()" "f.m()"
  test_parser ".(f m)(a)" "f.m(a)"
  test_parser ".(f m)(a b)" "f.m(a b)"
  # index access
  test_parser "__index(x 1)" "x[1]"
  test_parser "__index(x 1 2)" "x[1 2]"
  # steps
  test_parser "a; b" "a\nb"
  test_parser "a(b); c" "a b\nc"
  test_parser "a; b(c)" "a\nb c"
  # block
  test_parser "a(b)"      "a: b"
  test_parser "a(b(c))"   "a: b c"
  test_parser "a(b c)"    "a b: c"
  test_parser "a(b c(d))" "a b: c d"
  # indent
  test_parser "a(b)"            "a:\n  b"
  test_parser "a(b); c"         "a:\n  b\nc"
  test_parser "a(b; c)"         "a:\n  b\n  c"
  test_parser "a(b(c))"         "a:\n  b:\n    c"
  test_parser "a(b c)"          "a b:\n  c"
  test_parser "a(b c(d))"       "a b:\n  c d"
  test_parser "a(b c; d)"       "a b:\n  c\n  d"
  test_parser "a(b c(d); e)"    "a b:\n  c d\n  e"
  test_parser "a(b c(d e))"     "a b:\n  c d:\n  e"
  test_parser "a(b c(d e(f)))"  "a b:\n  c d:\n  e f"
  # comment
  test_parser "a = 1" "#comment\na = 1 # comment\n#comment"
  test_parser "a(b; c)" "a:\n  #comment\n  b\n  #comment\n  c\n  # comment"
  # combinations
  test_parser "!(a(b))" "!a(b)"
  test_parser "+(a(b) c)" "a(b) + c"
  test_parser ".(__index(a b) c)" "a[b].c"
  test_parser ".(__index(a b) c)(d)" "a[b].c(d)"
  # edge case
  test_parser "1" "1\n"
  test_parser "" " "
  test_parser "" "\n"

  def test_show expectation type:
    t.eq expectation show_type(type)
  test_show "a" tname("a" [])
  test_show "a[b c]" tname("a" [tname("b" []) tname("c" [])])
  test_show "1" tid(1)

  def test_infer expectation source:
    ps = parse source
    t.eq expectation show_type(infer(ps)) source ++ " :: " + stringify(ps)
  # primitives
  test_infer "bool" "true"
  test_infer "bool" "false"
  test_infer "int" "1"
  test_infer "float" "1.1"
  test_infer "string" "\"s\""
  test_infer "(1 1)" "x => x"
  # container
  ##test_infer "list[0]" "[]"
  ##test_infer "list[int]" "[1]"
  ### property access
  ##test_infer "int" "[].size"
  ### single operator
  ##test_parser "bool" "!true"
  ### binary operators
  ##test_parser "int" "1 + 2"
  ### definition
  ##test_parser "int" "a = 1"
  ##test_parser "(1 1)" "f a = a"
  ### function call
  ##test_parser "(int)" "f = () => 1"
  ##test_parser "int" "f = () => 1\nf()"
  ### method call
  ##test_parser "list[int]" "[1].map(x => x + 1)"
  ### index access
  ##test_parser "int" "[1][0]"
  ### steps
  ##test_parser "int" "true\n1"
  # combinations
  #test_infer "f x = x + 1\n(= g x (+ x 2))\n(+ (f 1) (g 1))" "int"
  #test_infer "_ f g x = g (f x)" "((1 2) (2 3) 1 3)"
  #test_infer "_ x y z = x z (y z)" "((1 2 3) (1 2) 1 3)"
  #test_infer "_ b x = if (x b) x (= _ x b)" "(1 (1 bool) (1 1))"
  #test_infer "_ x = if true x (if x true false)" "(bool bool)"
  #test_infer "_ x y = if x x y" "(bool bool bool)"
  #test_infer "_ n = (_ x = (x (_ y = y))) (_ f = f n)" "(1 1)"
  #test_infer "_ x y = x y" "((1 2) 1 2)"
  #test_infer "_ x y = x (y x)" "((1 2) ((1 2) 1) 2)"
  #test_infer "_ h t f x = f h (t f x)" "(1 ((1 2 3) 4 2) (1 2 3) 4 3)"
  #test_infer "_ x y = x (y x) (y x)" "((1 1 2) ((1 1 2) 1) 2)"
  #test_infer "id x = x\nf y = id (y id)" "(((1 1) 2) 2)"
  #test_infer "f x = x\ng = if (f true) (f 1) (f 2)" "int"
  #test_infer "f x = 3\ng = (f true) + (f 4)" "int"
  #test_infer "f x = x\ng y = y\nh b = if b (f g) (g f)" "(bool (1 1))"
  #test_infer "g1 x = x f\ng2 x = x f\nh b f z = if b (g1 z g2) (g2 z g1)" "(bool 1 (1 ((1 2) 2) 3) 3)"
  ## recursive
  #test_infer "f x = (f x)" "(1 2)"
  # type errors
  #reject("(+ 1 true)")

  log "ok"
