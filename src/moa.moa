def compile_to_js source:
  "const main = io => io.write(`Hello world`)"

struct type:
  name   string
  params list type

struct token:
  text string
  pos  int
  args list token
  type type

let tundef type "" []

def parse source:
  let eot token "" 0 [] tundef

  def stmt a:
    token "__stmt" 0 a tundef

  def call a:
    token "__call" 0 a tundef

  if source.trim().size == 0:
    return stmt []

  # operator | parenthesis | string | number | id | comment and spaces
  let regexp r'([!+\-*/%<>:!=^|&]+|[()\[\]{}]|r?"[^]*?(?<!\\)"|r?"[^]*?(?<!\\)"|-?[0-9]+(?:\.[0-9]+)|[0-9A-Za-z_]+|(?:#[^\n]*|[ \n])+)'
  let tokens source.trim().split(regexp).filter(s => s.size > 0).mapi(t,i => token t i [] tundef)

  var pos 0
  def peek:
    iif pos < tokens.size:
      tokens[pos]
      eot
  def read:
    if peek().text.match(r"^[ #]"):
      pos += 1
    peek()
  def many f g:
    #while pos < tokens.size && f read(): yield g()
    let a []
    while pos < tokens.size && f(read()):
      let prev pos
      let item g()
      if prev == pos:
        break
      a.push item
    a
  def until s:
    def check t:
      pos += t.text.has("\n").int
      if read().text == s:
        pos += 1
        return false
      true
    many check parse_exp
  def consume:
    let t read()
    if t.text == "":
        throw "out of index" pos tokens
    pos += 1
    t
  def indent t:
    t.text.split("\n").at(-1).size
  def squash a:
    iif a.size == 1:
      a[0]
      call a
  def alias t a:
    token a t.pos t.args t.type
  def parse_unit:
    def suffix t:
      let adjacent peek()
      let next read()
      iif:
        adjacent.text == "(" : pos += 1; suffix call([t] ++ until(")"))
        adjacent.text == "[" : pos += 1; suffix call([alias(adjacent "__index") t] ++ until("]"))
        adjacent.text == "." : pos += 1; suffix call([next t consume()])
        next.text     == "=>": pos += 1; call [next t parse_block()]
        next.text     == "," : suffix call([consume() t consume()])
        t
    let t consume()
    suffix case(t.text:
      "!": call [t parse_unit()]
      "-": call [t parse_unit()]
      "[": call [alias(t "list")] ++ until("]")
      "(": squash until(")")
      ":": parse_block()
      _ : t)
  def parse_exp:
    def is_op2 s:
      s.match(r"^:?[!+\-*/%<>!=^~|&]") && s != "!"
    let lhs parse_unit()
    iif is_op2(read().text):
      call [consume() lhs parse_exp()]
      lhs
  def parse_line:
    def f t:
      !t.text.has("\n") && t.text != ")" && t.text != "]"
    squash many(f parse_exp)
  def parse_lines n:
    def f:
      let t peek()
      if t.text.has("\n") && indent(t) == n:
        pos += 1
      parse_line()
    stmt many((t => true) f)
  def parse_block:
    let t read()
    iif t.text.has("\n"):
      parse_lines indent(t)
      parse_line()
  parse_lines 0

test t "parser":
  def show x:
    case x.text:
      "__call": "(" ++ x.args.map(show).join(" ") ++ ")"
      "__stmt": iif:
        x.args.size == 0: "()"
        x.args.size == 1: show x.args[0]
        "(__pack " ++ x.args.map(show).join(" ") ++ ")"
      _: x.text
  def eq expect source:
    let actual show(parse(source))
    if expect != actual:
      log " Expet:" expect
      log "Actual:" actual
      log "Source:" source
    t.eq expect actual

  # primitives
  eq "1" "1"
  eq "(- 1)" "-1"
  eq "1.0" "1.0"
  eq "id" "id"
  eq "\"h\\\"i\"" "\"h\\\"i\""
  eq "\"\\\\\"" "\"\\\\\""
  eq "r\"\\t\"" "r\"\\t\""
  eq "(=> a b)" "a => b"

  # container
  eq "(list)" "[]"
  eq "(list 1)" "[1]"
  eq "(list 1 2)" "[1 2]"

  # property access
  eq "(. a b)" "a.b"

  # single operator
  eq "(! a)" "!a"
  eq "((! a) b)" "!a b"

  # binary operators
  eq "(+ a b)" "a + b"
  eq "((+ a b) c)" "a + b c"

  # parentheses
  eq "1" "(1)"
  eq "(f 1)" "(f 1)"
  eq "(+ 1 (+ 2 3))" "1 + 2 + 3"
  eq "(+ (+ 1 2) 3)" "(1 + 2) + 3"

  # function call
  eq "(f 1)" "f 1"
  eq "(f 1)" "f(1)"
  eq "(f (g 1))" "f g(1)"
  eq "(f g 1)" "f g (1)"
  eq "(f)" "f()"
  eq "(f (+ 1 2) 3)" "f(1 + 2 3)"

  # method call
  eq "(. f m)" "f.m"
  eq "(. f 1)" "f.1"
  eq "((. f m))" "f.m()"
  eq "((. f m) a)" "f.m(a)"
  eq "((. f m) a b)" "f.m(a b)"
  eq "((. ((. a f) 1) g) 2)" "a.f(1).g(2)"

  # index access
  eq "(__index x 1)" "x[1]"
  eq "(x (list 1))" "x [1]"
  eq "(__index x 1 2)" "x[1 2]"
  eq "(. (__index x a) b)" "x[a].b"

  # indent
  eq "(a b)" "a:\n  b"
  eq "(a (b c))" "a:\n  b:\n    c"
  eq "(a (b (__pack c d)))" "a:\n  b:\n    c\n    d"
  eq "(a (__pack (b c) d))" "a:\n  b:\n    c\n  d"
  eq "(__pack (a (b c)) d)" "a:\n  b:\n    c\nd"
  eq "(__pack (a (__pack b (c d) e)) f)" "a:\n  b\n  c:\n    d\n  e\nf"

  # statement
  eq "(__pack a b)" "a\nb"
  eq "(__pack (a b) c)" "a b\nc"
  eq "(__pack a (b c))" "a\nb c"

  # comment
  eq "(= a 1)" "#comment\na = 1 # comment\n#comment"
  eq "(a (__pack b c))" "a:\n  #comment\n  b\n  #comment\n  c\n  # comment"

  # combinations
  eq "(! (a b))" "!a(b)"
  eq "(&& true (! false))" "true && !false"
  eq "(+ (a b) c)" "a(b) + c"
  eq "(. (__index a b) c)" "a[b].c"
  eq "((. (__index a b) c) d)" "a[b].c(d)"
  eq "(. (list) a)" "[].a"
  eq "((. a b) c)" "a.b c"
  eq "(. (list) size)" "[].size"
  eq "((. (list 1) m) a)" "[1].m a"
  eq "((. (list 1) m) a)" "[1].m(a)"
  eq "((. (list 1) m) (=> x (>= x 1)))" "[1].m(x => x >= 1)"
  eq "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
  eq "(=> (, a b) c)" "a,b => c"
  eq "(=> (, (, a b) c) d)" "a,b,c => d"
  eq "(=> a (b c))" "a => b c"
  eq "(=> a (+ 1 2))" "a => 1 + 2"
  eq "(=> a 1)" "a =>\n  1"
  eq "(=> a (__pack 1 2))" "a =>\n  1\n  2"

  # edge case
  eq "1" "1\n"
  eq "()" ""
  eq "()" "\n"
  eq "(f a b)" "f(a\nb\n)"


def infer root:
  var id 0
  def tnew:
    type (id+=1).string []
  def tmore t:
    type "__more" [t]
  def tfunc types:
    type "" types
  let tv1     tnew()
  let tbool   type "bool" []
  let tint    type "int" []
  let tfloat  type "float" []
  let tstring type "string" []
  let tlist   tfunc [tmore(tv1) type("list" [tv1])]
  let tprops  dict("list" dict(
    "size" _ => tint
    "map" t => tfunc([tfunc([t.params[0] tv1]) type("list" [tv1])])
    ))
  def is_tvar t:
    t.name.match(r"[0-9]")
  def prune t:
    t.params = t.params.map(prune)
    iif t.name == "__ref":
      t.params[0]
      t
  def tref a b:
    if !is_tvar(a):
      thorw "BugTRef"
    a.name = "__ref"
    a.params = [b]
    a
  def copy a b:
    a.name = b.name
    a.params = b.params

  def squash t:
    iif t.name == "" && t.params[0].name == "__more":
      t.params[1]
      t
  def unify a b:
    a = prune(a)
    b = prune(b)
    let va is_tvar a
    let vb is_tvar b
    iif:
      va && vb: tref a b
      va: tref a b
      vb: tref b a
      a.name == b.name && a.params.size == b.params.size: a.params.mapi(ap,i => unify(ap b.params[i])); a
      log("TypeInvalid" a b)
  def apply f a:
    iif:
      f.size == 0 && a.size > 0:
        throw "ArgumentsNotEnough"
      f.size == 0 && a.size == 0:
        throw "BugToApply"
      f.size == 1 && a.size == 0:
        f[0]
      f[0].name == "__more" && a.size == 0:
        apply f.slice(1) a
      f[0].name == "__more":
        unify f[0].params[0] a[0]
        apply f a.slice(1)
      unify f[0] a[0]; apply f.slice(1) a.slice(1)
  def call nodes ng tenv:
    let head nodes[0]
    case head.text:
      "=>":
        # TODO: accept two ore more arguments
        let t tnew()
        let ret analyze nodes[2] ng tenv ++ dict(nodes[1].text t)
        tfunc [t ret]
      ".":
        let target analyze nodes[1] ng tenv
        if is_tvar target:
          thorw "NotSupportedYet"
        tprops.get(target.name).get(nodes[2].text)(target)
      "let":
        let t analyze nodes[2] ng tenv
        tenv.set nodes[1].text t
        t
      "def":
        let fname nodes[1].text
        let args nodes.slice(2 (-1)).map(node => tuple(node.text tnew()))
        let ret analyze nodes.at(-1) ng tenv ++ dict(args) ++ dict(fname tnew())
        let f tfunc [ret] ++ args.map(arg => arg.1)
        tenv.set fname f
        f
      "__index":
        let a analyze nodes[1] ng tenv
        let index analyze nodes[2] ng tenv
        unify tint index
        a.params[0]
      _:
        let f analyze head ng tenv
        let a nodes.slice(1).map(node => analyze(node ng tenv))
        squash apply(f.params a)
  def analyze node ng tenv:
    node.type = case(node.text:
      "__stmt"           : node.args.map(x => analyze x ng tenv).at(-1)
      "__call"           : call node.args ng tenv
      r"^true|false$"    : tbool
      r"^[0-9]+\.[0-9]+$": tfloat
      r"^[0-9]+$"        : tint
      r"\""              : tstring
      _                  : tenv.get node.text)
  analyze root set() dict(
    "!" tfunc([tbool tbool])
    "+" tfunc([tint tint tint])
    "-" tfunc([tint tint tint])
    "*" tfunc([tint tint tint])
    "/" tfunc([tint tint tint])
    "list" tlist
    "true" tbool
    "false" tbool)

test t:
  def show t:
    iif t.name == "__ref":
      show t.params[0]
      t.name ++ iif(t.params.size == 0 "" "(" ++ t.params.map(show).join(" ") ++ ")")
  def simplify s:
    var d dict()
    var i 0
    s.replace r"[0-9]+" n => iif d.has(n):
      d.get(n)
      d.set(n i); i += 1; i - 1
  def eq expect source:
    let node parse source
    t.eq expect simplify(show(infer(node))) source

  # primitives
  eq "bool" "true"
  eq "bool" "false"
  eq "int" "1"
  eq "float" "1.1"
  eq "string" "\"s\""
  eq "(0 0)" "x => x"

  # container
  eq "list(0)" "[]"
  eq "list(int)" "[1]"

  # property access
  eq "int" "[].size"

  # single operator
  eq "bool" "!true"

  # binary operators
  eq "int" "1 + 2"

  # definition
  eq "int" "let a 1"
  eq "(int)" "def a: 1"
  eq "(0 0)" "def a b: b"

  # function call
  eq "int" "def f: 1\nf()"

  # method call
  eq "list(int)" "[1].map(x => x + 1)"

  # index access
  eq "int" "[1][0]"

  # steps
  eq "int" "true\n1"

  # combinations
  eq "int" "def f x: x + 1\ndef g x: x + 2\nf(1) + g(1)"
  #eq "_ f g x = g (f x)" "((1 2) (2 3) 1 3)"
  #eq "_ x y z = x z (y z)" "((1 2 3) (1 2) 1 3)"
  #eq "_ b x = if (x b) x (= _ x b)" "(1 (1 bool) (1 1))"
  #eq "_ x = if true x (if x true false)" "(bool bool)"
  #eq "_ x y = if x x y" "(bool bool bool)"
  #eq "_ n = (_ x = (x (_ y = y))) (_ f = f n)" "(1 1)"
  #eq "_ x y = x y" "((1 2) 1 2)"
  #eq "_ x y = x (y x)" "((1 2) ((1 2) 1) 2)"
  #eq "_ h t f x = f h (t f x)" "(1 ((1 2 3) 4 2) (1 2 3) 4 3)"
  #eq "_ x y = x (y x) (y x)" "((1 1 2) ((1 1 2) 1) 2)"
  #eq "id x = x\nf y = id (y id)" "(((1 1) 2) 2)"
  #eq "f x = x\ng = if (f true) (f 1) (f 2)" "int"
  #eq "f x = 3\ng = (f true) + (f 4)" "int"
  #eq "f x = x\ng y = y\nh b = if b (f g) (g f)" "(bool (1 1))"
  #eq "g1 x = x f\ng2 x = x f\nh b f z = if b (g1 z g2) (g2 z g1)" "(bool 1 (1 ((1 2) 2) 3) 3)"
  ## recursive
  #eq "f x = (f x)" "(1 2)"
  # type errors
  #reject("(+ 1 true)")
