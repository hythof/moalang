help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source = "const main = io => log(io)"

class type:
  id string
  params list[type]

union ast:
  abool bool
  aint int
  afloat float
  astring string
  alambda:
    args list[string]
    body ast
    type type
  aid:
    id string
    type type
  acall:
    head ast
    argv list[ast]
  adefine:
    id string
    body ast
  astatement list[ast]
  aop1:
    op string
    body ast
  aop2:
    op string
    lhs ast
    rhs ast
    type type
  aundef string

parse source =
  tokens =
    trim a =
      guard a.size == 0: []
      guard a[0].match(r"^[ \n\t]"): trim a.slice(1)
      guard a[-1].match(r"^[ \n\t]"): trim a.slice(0 -1)
      a
    regexp = r"((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\n]+(?:#[^\n]*|[ \t\n]+)*|\"[^]*?(?<!\\)\"|[A-Za-z0-9_]+|#[^\n]*)"
    trim source.rsplit(regexp).keep(t => t.size > 0 && !t.starts("#"))
  guard tokens.size == 0: astatement []
  pos = 0
  look_ahead = () =>
    guard pos >= tokens.size: ""
    guard tokens[pos].match(r"^[ \t]"):
      pos += 1
      look_ahead()
    tokens[pos]
  to_id_or_call a =
    guard a.size == 1: a[0]
    acall a[0] a.slice(1)
  parse_unit = () =>
    until end =
      h a =
        guard pos >= tokens.size: a
        guard look_ahead(pos) == end:
          pos += 1
          a
        h a ++ [parse_exp()]
      h []
    consume = () =>
      guard pos >= tokens.size: aundef ""
      t = tokens[pos]
      pos += 1
      guard t.match(r"^[ \t]")                : consume()
      guard t == "true"                       : abool true
      guard t == "false"                      : abool false
      guard t == "("                          : to_id_or_call until(")")
      guard t == "["                          : acall aid("list") until("]")
      guard t.starts("\"")                    : astring t.slice(1 -1).replace("\\t" "\t").replace("\\n" "\n")
      guard t.match(r"^[0-9.]+\.[0-9]+$")     : afloat t.float
      guard t.match(r"^[0-9]+")               : aint t.int
      guard t.match(r"^[a-zA-Z_]")            : aid t
      guard t == ":" && look_ahead().has("\n"): parse_statement()
      guard t == ":"                          : parse_line()
      aundef t
    suffix x =
      guard pos >= tokens.size: x
      guard x === aundef: aundef x
      guard tokens[pos] == ".":
        pos += 1
        field = tokens[pos]
        pos += 1
        suffix acall("." [x field])
      guard tokens[pos] == "(":
        pos += 1
        suffix acall(x until(")"))
      guard tokens[pos] == "[":
        pos += 1
        suffix acall("__index" [x] ++ until("]"))
      x
    suffix consume()
  parse_exp = () =>
    lhs = parse_unit()
    guard pos >= tokens.size: lhs
    guard lhs == aundef("!"): aop1 "!" parse_unit()
    lop = look_ahead()
    op2s = ", * ** / // % + ++ - >> << ^ & | := += -= *= /= %= **= < <= > >= == != === !== <=> && || =>".split " "
    priority op = op2s.index op
    guard op2s.has(lop):
      parse_unit() # move position to after binary operator
      head = look_ahead()
      rhs = parse_exp()
      guard head != "(" && rhs === aop2 && priority(lop) < priority(rhs.op): aop2 rhs.op aop2(lop lhs rhs.lhs) rhs.rhs # "1 * 2 + 3" -> (* 1 (+ 2 3)) -> (+ (* 1 2) 3)
      aop2 lop lhs rhs
    lhs
  parse_line = () =>
    head = parse_exp()
    f a =
      guard pos >= tokens.size || tokens[pos].has("\n"): to_id_or_call [head] ++ a
      guard head === aid && look_ahead() == "=":
        pos += 1
        parse_body = () =>
          guard look_ahead().has("\n"): parse_statement()
          parse_line()
        body = parse_body()
        guard a.size == 0: adefine head.id body
        adefine head.id alambda(a body)
      f a ++ [parse_exp()]
    f []
  parse_statement = () =>
    read_block indent lines =
      t = look_ahead()
      guard t.has("\n") && t.split("\n")[-1].size == indent:
        pos += 1
        read_block indent lines ++ [parse_line()]
      guard lines.size == 1: lines[0]
      astatement lines
    guard pos == 0: read_block 0 [parse_line()]
    guard look_ahead().has("\n"): read_block look_ahead().split("\n")[-1].size []
    fail "invalid indent"
  parse_statement()

test t "parser":
  stringify a =
    match a:
      x.adefine   : x.id ++ " = " ++ stringify(x.body)
      x.abool     : string x
      x.aint      : string x
      x.afloat    : string x
      x.astring   : string x
      x.astatement: "(" ++ x.map(stringify).join("; ") ++ ")"
      x.alambda   : x.args.map(stringify).join(",") ++ " => " ++ stringify(x.body)
      x.aid       : x.id
      x.acall     : "(" + ([x.head] ++ x.argv).map(stringify).join(" ") ++ ")"
      x.aop1      : "(" ++ x.op ++ " " ++ stringify(x.body) ++ ")"
      x.aop2      : "(" ++ x.op ++ " " ++ stringify(x.lhs) ++ " " ++ stringify(x.rhs) + ")"
      x.aundef    : "undefined(" ++ x ++ ")"
      x           : a
  test_stringify expectation ast = t.eq expectation stringify(ast) ast
  test_stringify "a = 1"    adefine("a" aint(1))
  test_stringify "1"        aint(1)
  test_stringify "1.1"      afloat(1.1)
  test_stringify "\"hi\""   astring("hi")
  test_stringify "(1; 2)"   astatement([aint(1) aint(2)])
  test_stringify "a,b => 1" alambda(["a" "b"] aint(1))
  test_stringify "a"        aid("a")
  test_stringify "true"     abool(true)
  test_stringify "(! true)" aop1("!" true)
  test_stringify "(+ 1 2)"  aop2("+" aint(1) aint(2))
  test_stringify "a,b => 1" alambda(["a" "b"] aint(1))

  test_parser expectation source = t.eq expectation stringify(parse(source)) source
  # primitives
  test_parser "1" "1"
  test_parser "1.1" "1.1"
  test_parser "id" "id"
  test_parser "\"hi\"" "\"hi\""
  test_parser "\"\\t\"" "\"\\t\""
  test_parser "true" "true"
  # container
  test_parser "(list)" "[]"
  test_parser "(list 1 2)" "[1 2]"
  test_parser "(=> a a)" "a => a"
  test_parser "(=> (, a b) a)" "a,b => a"
  test_parser "(=> p (+ 1 2))" "p => 1 + 2"
  # definition
  test_parser "a = 1" "a = 1"
  test_parser "f = a => a" "f a = a"
  test_parser "a = (+ 1 2)" "a = 1 + 2"
  test_parser "f = a => a" "f a =\n  a"
  test_parser "f = a => (b = 1; (+ a b))" "f a =\n  b = 1\n  a + b"
  # property access
  test_parser "(. a b)" "a.b"
  test_parser "((. a b) c)" "a.b c"
  test_parser "(. (list) a)" "[].a"
  test_parser "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
  # single operator
  test_parser "(! true)" "!true"
  # binary operators
  test_parser "(+ 1 2)" "1 + 2"
  test_parser "(+ 1 (+ 2 3))" "1 + 2 + 3"
  test_parser "(+ (* 1 2) 3)" "1 * 2 + 3"
  test_parser "(!= 1 1)" "1 != 1"
  test_parser "(+= a 1)" "a += 1"
  test_parser "(+= a (+ 1 2))" "a += 1 + 2"
  # parentheses
  test_parser "1" "(1)"
  test_parser "(f 1)" "(f 1)"
  test_parser "(+ (+ 1 2) 3)" "(1 + 2) + 3"
  test_parser "(* 1 (+ 2 3))" "1 * (2 + 3)"
  test_parser "(* (+ 1 2) 3)" "(1 + 2) * 3"
  # function call
  test_parser "(f)" "f()"
  test_parser "(f 1)" "f(1)"
  test_parser "(f (+ 1 2))" "f(1 + 2)"
  # method call
  test_parser "(. f m)" "f.m"
  test_parser "(. f 1)" "f.1"
  test_parser "((. f m))" "f.m()"
  test_parser "((. f m) a)" "f.m(a)"
  test_parser "((. f m) a b)" "f.m(a b)"
  # index access
  test_parser "(__index x 1)" "x[1]"
  test_parser "(__index x 1 2)" "x[1 2]"
  # steps
  test_parser "(a; b)" "a\nb"
  test_parser "((a b); c)" "a b\nc"
  test_parser "(a; (b c))" "a\nb c"
  # block
  test_parser "(a b)" "a: b"
  test_parser "(a (b c))" "a: b c"
  test_parser "(a b c)" "a b: c"
  test_parser "(a b (c d))" "a b: c d"
  # indent
  test_parser "(a b)"               "a:\n  b"
  test_parser "((a b); c)"          "a:\n  b\nc"
  test_parser "(a (b; c))"          "a:\n  b\n  c"
  test_parser "(a (b c))"           "a:\n  b:\n    c"
  test_parser "(a b c)"             "a b:\n  c"
  test_parser "(a b (c d))"         "a b:\n  c d"
  test_parser "(a b (c; d))"        "a b:\n  c\n  d"
  test_parser "(a b ((c d); e))"    "a b:\n  c d\n  e"
  test_parser "(a b (c d e))"       "a b:\n  c d:\n  e"
  test_parser "(a b (c d (e f)))"   "a b:\n  c d:\n  e f"
  # comment
  test_parser "a = 1" "#comment\na = 1 # comment\n#comment"
  test_parser "(a (b; c))" "a:\n  #comment\n  b\n  #comment\n  c\n  # comment"
  # combinations
  test_parser "(! (a b))" "!a(b)"
  test_parser "(+ (a b) c)" "a(b) + c"
  test_parser "(. (__index a b) c)" "a[b].c"
  test_parser "((. (__index a b) c) d)" "a[b].c(d)"
  # combinations
  test_parser "(! (a b))" "!a(b)"
  test_parser "(+ (a b) c)" "a(b) + c"
  # edge case
  test_parser "1" "1\n"
  test_parser "()" " "
  test_parser "()" "\n"
  log "ok"
