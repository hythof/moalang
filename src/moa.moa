help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source = "const main = io => log(io)"

class token:
  label string
  line int
  column int

union type:
  tundef # no type determined yet
  tnil   # for tag only union and field less struct
  tbool
  tint
  tfloat
  tstring
  tlambda list[type]
  tset type
  tlist type
  tdict type type
  ttype list[tuple[string type]]

union ast:
  adefine:
    id string
    desc ast
  abool bool
  aint int
  afloat float
  astring string
  atuple list[ast]
  astatement list[ast]
  alambda:
    args list[string]
    body ast
    type type
  aid:
    id string
    type type
  acall:
    head ast
    argv list[ast]
  aop1:
    op string
    body ast
  aop2:
    op string
    lhs ast
    rhs ast
  aundef string

parse source =
  # list[string]
  tokens =
    trim a =
      guard a.size == 0: []
      guard a[0].match(r"^[ \r\n\t]"): trim a.slice 1
      guard a[-1].match(r"^[ \r\n\t]"): trim a.slice 0 -1
      a
    regexp = r"((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\r\n]+(?:#[^\n]*|[ \t\r\n]+)*|\"[^]*?(?<!\\)\"|[A-Za-z0-9_]+|#[^\n]*)"
    source.rsplit(regexp).keep(t => t.size > 0 && !t.starts("#"))
  pos = 0
  top = () =>
    call a =
      guard a.size == 1: a[0]
      acall a[0] a.slice(1)
    until end =
      f a =
        guard pos >= tokens.size: a
        guard tokens[pos + tokens[pos].match(r"^[ \t]").int] == end:
          unit()
          a
        f a ++ exp()
      f []
    unit = () =>
      guard pos >= tokens.size: aundef ""
      t = tokens[pos]
      pos += 1
      guard t.match(r"^[ \t]+$")         : unit()
      guard t == "true"                  : abool true
      guard t == "false"                 : abool false
      guard t == "("                     : call until(")")
      guard t == "["                     : acall aid("list") until("]")
      guard t == "{"                     : acall aid("dict") until("}").keep(x => x != aundef(":"))
      guard t.starts("\"")               : astring t.slice(1 -1).replace("\\t" "\t").replace("\\n" "\n")
      guard t.match(r"^[0-9.]+\.[0-9]+$"): afloat t.float
      guard t.match(r"^[0-9]+")          : aint t.int
      guard t.match(r"^[a-zA-Z_]")       : aid t
      aundef t
    exp = () =>
      lhs = unit()
      guard pos >= tokens.size: lhs
      lop = tokens[pos + tokens[pos].match(r"^[ \t]").int]
      op2s = ". , * ** / // % + ++ - >> << ^ & | := += -= *= /= %= **= < <= > >= == != === !== <=> && || =>".split " "
      priority op = op2s.index op
      guard lhs == aundef("!"): aop1 "!" unit()
      guard op2s.has(lop):
        unit() # move position to after binary operator
        rhs = exp()
        guard rhs === aop2 && priority(lop) < priority(rhs.op): aop2 rhs.op aop2(lop lhs rhs.lhs) rhs.rhs # "1 * 2 + 3" -> (* 1 (+ 2 3)) -> (+ (* 1 2) 3)
        aop2 lop lhs rhs
      lhs
    line = () =>
      head = exp()
      f a =
        guard pos >= tokens.size: a
        guard tokens[pos].has("\n"):
          pos += 1
          a
        f a ++ [exp()]
      argv = f []
      index = argv.index aundef("=")
      guard argv.size == 0: head
      guard head === aid && index == 0: adefine head.id call(argv.slice(1))
      guard head === aid && index >= 1: adefine head.id alambda(argv.slice(0 index) call(argv.slice(index + 1)))
      acall head argv
    statement = () =>
      f a =
        l = line()
        guard l == aundef(""): a
        f a ++ [l]
      lines = f []
      guard lines.size == 1: lines[0]
      astatement lines
    statement()
  top()

test t "parser":
  stringify a =
    call x = "(" + ([x.head] ++ x.argv).map(stringify).join(" ") ++ ")"
    match a:
      x.adefine   : x.id ++ " = " ++ stringify(x.desc)
      x.abool     : string x
      x.aint      : string x
      x.afloat    : string x
      x.astring   : string x
      x.astatement: x.map(stringify).join("\n")
      x.alambda   : x.args.map(stringify).join(",") ++ " => " ++ stringify(x.body)
      x.aid       : x.id
      x.acall     : call x
      x.aop1      : "(" ++ x.op ++ " " ++ stringify(x.body) ++ ")"
      x.aop2      : "(" ++ x.op ++ " " ++ stringify(x.lhs) ++ " " ++ stringify(x.rhs) + ")"
      x.aundef    : "undefined(" ++ x ++ ")"
      x           : a

  t1 expectation ast = t.eq expectation stringify(ast)
  t1 "a = 1" adefine("a" aint(1))
  t1 "1" aint(1)
  t1 "1.1" afloat(1.1)
  t1 "\"hi\"" astring("hi")
  t1 "1\n2" astatement([aint(1) aint(2)])
  t1 "a,b => 1" alambda(["a" "b"] aint(1))
  t1 "a" aid("a")
  t1 "true" abool(true)
  t1 "(! true)" aop1("!" true)
  t1 "(+ 1 2)" aop2("+" aint(1) aint(2))
  t1 "a,b => 1" alambda(["a" "b"] aint(1))

  test expectation source = t.eq expectation stringify(parse(source))

  # primitives
  test "1" "1"
  test "1.1" "1.1"
  test "id" "id"
  test "\"hi\"" "\"hi\""
  test "\"\\t\"" "\"\\t\""
  test "true" "true"
  # container
  test "(list)" "[]"
  test "(list 1 2)" "[1 2]"
  test "(dict)" "{}"
  test "(dict \"a\" 1)" "{\"a\":1}"
##  test "(dict \"a\" (+ 1 2))" "{\"a\":(1+2)}"
##  test "(dict (+ 1 2) (+ 3 4))" "{(1+2):(3+4)}"
##  test "(dict \"a\" 1 \"b\" (+ 1 2) c (+ 3 4))" "{\"a\":1 \"b\":(1+2) (c):(3+4)}"
##  test "(dict \"a\" 1)" "[a:1]"
##  test "(dict \"a\" (+ 1 2))" "[a:(1+2)]"
##  test "(dict (+ 1 2) (+ 3 4))" "[(1+2):(3+4)]"
##  test "(dict \"a\" 1 \"b\" (+ 1 2) c (+ 3 4))" "[a:1 b:(1+2) (c):(3+4)]"
##  test "(__call class)" "{}"
##  test "(class a 1)" "{a=1}"
##  test "(class a a b b c (+ 1 2) d 3)" "{a b c=(1+2) d=3}"
##  test "(=> a a)" "a => a"
##  test "(=> (, a b) a)" "a,b => a"
##  test "(=> p (+ 1 2))" "p => 1 + 2"
##  test "(. int)" ".int"
##  test "(f (. int))" "f .int"
##
  # definition
  test "a = 1" "a = 1"
  test "f = a => a" "f a = a"
  test "a = (+ 1 2)" "a = 1 + 2"
##  test "(= (f a) (__pack (= b 1) (+ a b)))" "f a =\n  b = 1\n  a + b"
##
##  # property access
  test "(. a b)" "a.b"
  test "((. a b) c)" "a.b c"
  test "(. (list) a)" "[].a"
##  test "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
##
  # single operator
  test "(! true)" "!true"
  # binary operators
  test "(+ 1 2)" "1 + 2"
  test "(+ 1 (+ 2 3))" "1 + 2 + 3"
  test "(+ 1 (* 2 3))" "1 + 2 * 3"
  test "(+ (* 1 2) 3)" "1 * 2 + 3"
  test "(!= 1 1)" "1 != 1"
  test "(+= a 1)" "a += 1"
  test "(+= a (+ 1 2))" "a += 1 + 2"

##  # parentheses
  test "1" "(1)"
  test "(f 1)" "(f 1)"
  test "(+ 1 2)" "(1 + 2)"
#  test "(* 1 (+ 2 3))" "1 * (2 + 3)" # fix me
#  test "(* (+ 1 2) 3)" "(1 + 2) * 3" # fix me

##  # function call
##  test "(__call f)" "f()"
##  test "(f 1)" "f(1)"
##  test "(f (+ 1 2))" "f(1 + 2)"
##
##  # method call
##  test "(. f m)" "f.m"
##  test "(. f 1)" "f.1"
##  test "(__call (. f m))" "f.m()"
##  test "((. f m) a)" "f.m(a)"
##  test "((. f m) a b)" "f.m(a b)"
##
##  # index access
##  test "(__index x 1)" "x[1]"
##  test "(__index x 1 2)" "x[1 2]"
##
##  # steps
##  test "(__pack a b)" "a\nb"
##  test "(__pack (a b) c)" "a b\nc"
##  test "(__pack a (b c))" "a\nb c"
##
##  # block
##  test "(: a b)" "a: b"
##  test "(: (a b) c)" "a b: c"
##  test "(: (a b) (c d))" "a b: c d"
##
##  # indent
##  test "(: a b)" "a:\n  b"
##  test "(: a (: b c))" "a:\n  b:\n    c"
##  test "(: a (: b (__pack c d)))" "a:\n  b:\n    c\n    d"
##  test "(: a (__pack (: b c) d))" "a:\n  b:\n    c\n  d"
##  test "(__pack (: a (: b c)) d)" "a:\n  b:\n    c\nd"
##  test "(__pack (: a (__pack b (: c d) e)) f)" "a:\n  b\n  c:\n    d\n  e\nf"
##
##  # combinations
##  test "(! (a b))" "!a(b)"
##  test "(+ (a b) c)" "a(b) + c"
##
##  # edge case
##  test "1" "1\n"
##  test "()" "n"
##  test "()" "\n"
  log "ok"
