help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source = "const main = io => log(io)"

class token:
  text string
  indent int
  lineno int
  column int

union type:
  tundef
  tlambda list[type]
  tname:
    name string
    params list[type]
  tid:
    id int
    type type

union ast:
  aid:
    token token
    type type
  acall:
    head ast
    argv list[ast]
  alambda:
    args list[token]
    body ast
  alet:
    id token
    body ast
  astatement:
    lines list[ast]

show_type t = match t:
  _.tundef : "?"
  x.tlambda: "(" ++ x.map(show_type).join(" ") ++ ")"
  x.tname  :
    guard x.params.size == 0: x.name
    x.name ++ "[" ++ x.params.map(show_type).join(" ") ++ "]"
  x.tid    :
    match x.type:
      _.tundef: x.id.string
      t: show_type t

parse source =
  tokens =
    regexp = r"((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\n]+(?:#[^\n]*|[ \t\n]+)*|\"[^]*?(?<!\\)\"|[A-Za-z0-9_]+|#[^\n]*)"
    indent = 0
    lineno = 1
    column = 1
    source.rsplit(regexp).fmap text =>
      guard text == "": []
      guard text.has("\n"):
        indent := text.split("\n")[-1].size
        lineno += text.split("\n").size - 1
        column := indent
        []
      guard text.match(r"^[ \t#]"): []
      t = token text indent lineno column
      column += text.size
      t
  new_aid t = aid t tundef
  new_aid_text t text = aid token(text t.indent t.lineno t.column) tundef
  guard tokens.size == 0: astatement []
  pos = 0
  end_by forward check =
    loop a =
      guard pos >= tokens.size: a
      guard check(tokens[pos]): a
      loop a ++ [forward()]
    loop []
  parse_unit = () =>
    until end = end_by parse_exp t =>
      guard t.text == end:
        pos += 1
        true
      false
    consume = () =>
      t = tokens[pos]
      pos += 1
      match t.text:
        "(": until(")")[0]
        "[": acall(new_aid_text(t "list") until("]"))
        ":": parse_block()
        _: new_aid t
    suffix x =
      guard pos >= tokens.size: x
      t = tokens[pos]
      match t.text:
        ".":
          pos += 2
          suffix acall(new_aid(t) [x new_aid(tokens[pos - 1])])
        ",":
          remain = end_by consume t =>
            guard t.text == ",":
              pos += 1
              false
            true
          guard pos < tokens.size && tokens[pos].text == "=>": alambda [x] ++ remain parse_exp()
          suffix acall(new_aid_text(t "tuple") [x] ++ remain)
        "(":
          pos += 1
          suffix acall(x until(")"))
        "[":
          pos += 1
          suffix acall(new_aid_text(t "__index") [x] ++ until("]"))
        _: x
    suffix consume()
  parse_exp = () =>
    lhs = parse_unit()
    guard pos >= tokens.size: lhs
    guard lhs === aid && lhs.token.text == "!": acall new_aid(lhs.token) [parse_unit()]
    lop_token = tokens[pos]
    op2s = ", * ** / // % + ++ - >> << ^ & | := += -= *= /= %= **= < <= > >= == != === !== <=> && ||".split " "
    guard op2s.has(lop_token.text):
      pos += 1
      rhs_first_text = tokens[pos].text
      rhs = parse_exp()
      rcall = rhs
      guard rhs_first_text != "(" && rcall === acall && rcall.argv.size == 2:
        rop = rcall.head
        guard rop === aid && op2s.has(rop.token.text) && op2s.index(lop_token.text) < op2s.index(rop.token.text):
          acall rcall.head [acall(new_aid(lop_token) [lhs rcall.argv[0]]) rcall.argv[1]] # "1 * 2 + 3" -> (* 1 (+ 2 3)) -> (+ (* 1 2) 3)
        acall new_aid(lop_token) [lhs rhs]
      acall new_aid(lop_token) [lhs rhs]
    guard lop_token.text == "=>" && lhs === aid:
      pos += 1
      alambda [lhs.token] parse_exp()
    lhs
  parse_block = () =>
    guard tokens[pos - 1].indent < tokens[pos].indent: parse_statement()
    parse_line()
  parse_line = () =>
    first_pos = pos
    first_lineno = tokens[pos].lineno
    loop a =
      guard pos >= tokens.size || tokens[pos].lineno != first_lineno:
        guard a.size == 1: a[0]
        acall a[0] a.slice(1)
      guard tokens[pos].text == "=":
        items = tokens.slice(first_pos pos-1)
        pos += 1
        guard a.size == 1: alet items[0] parse_block()
        alet items[0] alambda(items.slice(1) parse_block())
      loop a ++ [parse_exp()]
    loop []
  parse_statement = () =>
    current_indent = tokens[pos].indent
    astatement end_by(parse_line t => t.indent != current_indent)
  parse_statement()

infer ast =
  tbool = tname "bool" []
  tint = tname "int" []
  tfloat = tname "float" []
  tstring = tname "string" []
  id = 0
  new_tid = () => tid(id+=1 tundef)
  inf_with ast env =
    inf x = inf_with x env
    inf_value s =
      guard s == "true" || s == "false": tbool
      guard s.match(r"^[0-9]+\.[0-9]+$"): tfloat
      guard s.match(r"^[0-9]+$"): tint
      guard s.match(r"^[A-Za-z_]"): env[s]
      guard s.starts("\""): tstring
      tundef
    match ast:
      x.aid:
        x.type := inf_value x.token.text
      x.acall:
        tundef
      x.alambda:
        argst = x.args.map(t => t.text, new_tid())
        new_env = env ++ argst.dict()
        tlambda argst.map(x => x[1]) ++ [inf_with(x.body new_env)]
      x.astatement:
        x.lines.map(inf)[-1]
  inf_with ast dict()
#union type:
#  tundef
#  tlambda list[type]
#  tname:
#    name string
#    params list[type]
#  tid:
#    id int
#    token token
#    type type
#union ast:
#  aid:
#    token token
#    type type
#  acall:
#    head ast
#    argv list[ast]
#  alambda:
#    args list[ast]
#    body ast
#  alet:
#    id token
#    body ast

test t "parser":
  stringify x =
    match x:
      x.aid        : x.token.text
      x.acall      : stringify(x.head) ++ "(" ++ x.argv.map(stringify).join(" ") ++ ")"
      x.alambda    : "(" ++ x.args.map(x => x.text).join(",") + " => " + stringify(x.body) ++ ")"
      x.alet       : x.id.text ++ " = " ++ stringify(x.body)
      x.astatement : x.lines.map(stringify).join("; ")
  tx = token "x" 0 0 0
  x = aid tx tundef
  test_stringify expectation input = t.eq expectation stringify(input)
  test_stringify "x"        x
  test_stringify "x(x)"     acall(x [x])
  test_stringify "(x => x)" alambda([tx] x)
  test_stringify "y = x"    alet(token("y" 0 0 0) x)
  test_stringify "x; x"     astatement([x x])

  test_parser expectation source = t.eq expectation stringify(parse(source)) source
  test_parser "(a => a)" "a => a"

  # primitives
  test_parser "1" "1"
  test_parser "1.1" "1.1"
  test_parser "id" "id"
  test_parser "\"hi\"" "\"hi\""
  test_parser "\"\\t\"" "\"\\t\""
  test_parser "true" "true"
  test_parser "tuple(a b)" "a,b"
  test_parser "tuple(a b c)" "a,b,c"
  test_parser "(a => a)" "a => a"
  # container
  test_parser "list()" "[]"
  test_parser "list(1 2)" "[1 2]"
  # property access
  test_parser ".(a b)" "a.b"
  test_parser ".(a b)(c)" "a.b c"
  test_parser ".(list() a)" "[].a"
  test_parser "(p => +(.(p x) .(p y)))" "p => p.x + p.y"
  # single operator
  test_parser "!(true)" "!true"
  # binary operators
  test_parser "+(1 2)" "1 + 2"
  test_parser "+(1 +(2 3))" "1 + 2 + 3"
  test_parser "+(*(1 2) 3)" "1 * 2 + 3"
  test_parser "!=(1 1)" "1 != 1"
  test_parser "+=(a 1)" "a += 1"
  test_parser "+=(a +(1 2))" "a += 1 + 2"
  # parentheses
  test_parser "1" "(1)"
  test_parser "+(+(1 2) 3)" "(1 + 2) + 3"
  test_parser "*(1 +(2 3))" "1 * (2 + 3)"
  test_parser "*(+(1 2) 3)" "(1 + 2) * 3"
  # definition
  test_parser "a = 1" "a = 1"
  test_parser "f = (a => a)" "f a = a"
  test_parser "a = +(1 2)" "a = 1 + 2"
  test_parser "f = (a => a)" "f a =\n  a"
  test_parser "f = (a => a; b)" "f a =\n  a\n  b"
  test_parser "f = (a => b = 1; +(a b))" "f a =\n  b = 1\n  a + b"
  # function call
  test_parser "f()" "f()"
  test_parser "f(1)" "f(1)"
  test_parser "f(+(1 2))" "f(1 + 2)"
  # method call
  test_parser ".(f m)" "f.m"
  test_parser ".(f 1)" "f.1"
  test_parser ".(f m)()" "f.m()"
  test_parser ".(f m)(a)" "f.m(a)"
  test_parser ".(f m)(a b)" "f.m(a b)"
  # index access
  test_parser "__index(x 1)" "x[1]"
  test_parser "__index(x 1 2)" "x[1 2]"
  # steps
  test_parser "a; b" "a\nb"
  test_parser "a(b); c" "a b\nc"
  test_parser "a; b(c)" "a\nb c"
  # block
  test_parser "a(b)"      "a: b"
  test_parser "a(b(c))"   "a: b c"
  test_parser "a(b c)"    "a b: c"
  test_parser "a(b c(d))" "a b: c d"
  # indent
  test_parser "a(b)"            "a:\n  b"
  test_parser "a(b); c"         "a:\n  b\nc"
  test_parser "a(b; c)"         "a:\n  b\n  c"
  test_parser "a(b(c))"         "a:\n  b:\n    c"
  test_parser "a(b c)"          "a b:\n  c"
  test_parser "a(b c(d))"       "a b:\n  c d"
  test_parser "a(b c; d)"       "a b:\n  c\n  d"
  test_parser "a(b c(d); e)"    "a b:\n  c d\n  e"
  test_parser "a(b c(d e))"     "a b:\n  c d:\n  e"
  test_parser "a(b c(d e(f)))"  "a b:\n  c d:\n  e f"
  # comment
  test_parser "a = 1" "#comment\na = 1 # comment\n#comment"
  test_parser "a(b; c)" "a:\n  #comment\n  b\n  #comment\n  c\n  # comment"
  # combinations
  test_parser "!(a(b))" "!a(b)"
  test_parser "+(a(b) c)" "a(b) + c"
  test_parser ".(__index(a b) c)" "a[b].c"
  test_parser ".(__index(a b) c)(d)" "a[b].c(d)"
  # edge case
  test_parser "1" "1\n"
  test_parser "" " "
  test_parser "" "\n"

  test_show expectation type = t.eq expectation show_type(type)
  test_show "?" tundef
  test_show "(? ?)" tlambda([tundef tundef])
  test_show "a" tname("a" [])
  test_show "a[b c]" tname("a" [tname("b" []) tname("c" [])])
  test_show "1" tid(1 tundef)
  test_show "a" tid(1 tname("a" []))

  test_infer expectation source = t.eq expectation show_type(infer(parse(source))) source
  test_infer "bool" "true"
  test_infer "bool" "false"
  test_infer "int" "1"
  test_infer "float" "1.1"
  test_infer "string" "\"s\""
  test_infer "(1 1)" "x => x"
  log "ok"
