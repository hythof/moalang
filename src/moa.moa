# data type
token::
  tag string
  code string
  pos int
  indent int
ast:|
  aint value token
  astr value token
  aid name token
  apair value token
  alist values [token]
  afunc name token, args [token], body ast
  acall target ast, argv [token]
  aop2 op token, lhs ast, rhs ast
  atype name token, targs [token], members [token token]

# helper
many_acc f acc: f.then(c => many_acc(f acc.concat([c]))).alt(acc)
many f: many_acc(f [])
many1 f:
  c = f
  cs = many(f)
  [c].concat(cs)

# main process
op2s: "&& || == != => <= < >= > := = + - * / % .".split(" ")
syms: ": ( ) [ ]".split(" ").concat(op2s)
tokenize src:
  pos <- 0
  indent <- 0
  create tag code: token(tag code pos indent)
  equal s:
    ss = src.slice(pos pos+s.count)
    #__dump(["equal" src (ss==s) pos s ss])
    guard(ss == s)
    pos += s.count
    s
  satisfy f:
    c = src.at(pos)
    #__dump(["satisfy" src f(c) pos c])
    guard(f(c))
    pos += 1
    c
  read_chars n:
    satisfy(c => (c == n.char))
    cs = many(satisfy(c => c != n.char))
    satisfy(c => (c == n.char))
    create("str" cs.join(""))
  not_chars s:
    many(satisfy(c => (c != s)))
  many1t tag f: many1(f).then(cs => create(tag cs.join("")))
  read_int: many1t("int" satisfy(c => ("0" <= c) && (c <= "9")))
  read_id: many1t("id" satisfy(c => (("a" <= c) && (c <= "z")) || (c == "_")))
  read_str: read_chars(34).alt(read_chars(96))
  read_spaces:
    t = many1t("spaces" satisfy(c => " \n#".includes(c)))
    t.code.split("\n").slice(1).last.then(s => indent := s.count).alt(0)
    t
  read_sym:
    syms.first(equal).then(s => create("sym" s))
  read_top: read_id.alt(read_int read_str read_spaces read_sym)
  tokens = many(read_top)
  assert(pos == src.count)
  tokens.filter(t => t.tag != "spaces")
parse tokens:
  pos <- 0
  consume f:
    t = tokens.at(pos)
    guard(f(t))
    pos += 1
    t
  look:
    tokens.at(pos).alt(token("eot" ""))
  consume_id:
    consume(t => t.tag == "id")
  consume_code s:
    consume(t => t.code == s)
  consume_between l r c:
    consume_code(l)
    ret = c
    consume_code(r)
    ret
  parse_define:
    name = consume_id
    args = many(consume_id)
    mark = consume(t => ["::" ":|" ":"].includes(t.code))
    read_type:
      atype(name args [])
    match(mark.code
      ":" parse_exp.then(body => afunc(name args body))
      ":|" read_type
      "::" read_type)
  parse_unit:
    parse_parenthesis:
      consume_between("(" ")" parse_exp).then(apair)
    parse_list:
      consume_between("[" "]" many(parse_exp)).then(alist)
    parse_int:
      consume(t => t.tag == "int").then(aint)
    parse_str:
      consume(t => t.tag == "str").then(astr)
    parse_id:
      consume(t => t.tag == "id").then(aid)
    parse_call target:
      consume_code("(")
      argv = many(parse_exp)
      consume_code(")")
      acall(target argv)
    val = parse_parenthesis.alt(parse_list parse_int parse_str parse_id)
    parse_call(val).alt(val)
  parse_exp:
    token = parse_unit
    parse_op2:
      op = consume(t => op2s.includes(t.code))
      rhs = parse_exp
      aop2(op token rhs)
    parse_op2.alt(token)

  defines = many(parse_define)
  assert(tokens.count == pos tokens.at(pos))
  defines
generate defines:
  gen a: match(a
    aint  a.value.code
    astr  a.value.code.string
    aid   a.name.code
    apair ("(" + gen(a.value) + ")")
    atype ("const " + a.name.code + " = (" + keys(a.members) + ")" + " => ({" + keys(a.members) + "})")
    alist ("[" + a.values.map(gen).join(",") + "]")
    afunc ("const " + a.name.code + " = " + arrow(a.args) + gen(a.body))
    acall call(gen(a.target) a.argv.map(gen))
    aop2  (wrap(a.lhs) + a.op.code + gen(a.rhs)))
  call name argv: if(
    (name == "if") buildin_if(argv)
    name + "(" + argv.join(",") + ")")
  buildin_if argv: argv.joinWith(n => if((n%2)==0 "?" ":"))
  arrow args: if(args.present "(" + args.map(a=>a.code).join(",") + ")=>" "")
  keys xs: xs.map(x => x.at(0).code).join(",")
  wrap a: match(a
    aint "(" + gen(a) + ")"
    _ gen(a))
  defines.map(gen).join("\n")
compile src:
  tokens = tokenize(src)
  defines = parse(tokens)
  generate(defines)
