hint compile string string
def compile src:
  let tokens:
    let reg `([():\\[\\]]|[\\+\\-\\*\\/%&|=><\\.]+|"[^"]*?"|[ \\n]+|[a-zA-Z0-9_,]+(?:\\(\\)|\\(?))`
    src.rsplit(reg).map(t => t.rsub(`^ +` "")).keep(x => x != "")
  src

def selfcheck t:
  def eq expect src:
    t.eq expect t.run_js(src)

  # literals
  eq 1 "1"
  eq "hi" `"hi"`
  eq "hi" "`hi`"

  # int

  # string

  # array

  # function
  # struct
  # algebraic data type
  # variable
  # constant
  # branch
  # error handling
  # do block
  # comments
  # syntax combinations
  # bug fixes

#  // literals
#  exp('a`b', '```a`b```')
#  exp('1 + 1 = 2', '`${a} + ${a} = ${b}`', 'let a 1', 'let b 2')
#  exp('1 + 1 = 2', '```${a} + ${a} = ${b}```', 'let a 1', 'let b 2')
#  exp([1, 2], '[1 2]')
#  exp(1, '(n => n) 1')
#  exp(3, '(a,b => a + b) 1 2')
#
#  // method chain
#  exp([2, 3], '[1 2].map(n => n + 1)')
#  exp([2, 3], '[1 2 3].map(n => n + 1).keep(n => n <= 3)')
#
#  // int
#  exp(-1, '(-1)')
#  exp(0, '-1 + 1')
#  exp(0, 'add 1 (-1)', 'def add a b: a + b')
#
#  // string
#  exp(2, '"hi".size')
#  exp('i', '"hi".at 1')
#  exp('h', '"hi".at((-2))')
#  exp('Out of index', '"hi".at 3')
#  exp(['a', 'b'], '"a,b".split ","')
#  exp(true, '"hi".contains "h"')
#  exp(false, '"hi".contains "z"')
#  exp('heo', '"hello".sub "l" ""')
#
#  // string with regular expression
#  exp('h_o', '"hello".rsub `[el]+` "_"')
#  exp(['1', '+', '2'], '"1 + 2".rsplit(`([0-9\+])`).keep(x => x != "" && x != " ")')
#
#  // array
#  exp(2, '[1 2].size')
#  exp([1, 2], '[1].append 2')
#  exp([2, 3], '[1 2].map n => n + 1')
#  exp([1, 3], '[1 2 3].keep n => (n % 2) == 1')
#  exp(true, '[1 2].contains 1')
#  exp(false, '[1 2].contains 3')
#
#  // function
#  exp(1, 'one()', 'def one: 1')
#  exp(3, 'add 1 2', 'def add a b: a + b')
#  exp(6, 'calc 2 3', `def calc a b:
#  def mul a b: a * b
#  mul a b`)
#  exp(3, `
#  var a 1
#  def inc: a += 1
#  def twice f:
#    f()
#    f()
#  twice inc
#  a`)
#
#  // struct
#  exp({x:1, y:2}, 'vector2 1 2', 'struct vector2:\n  x int\n  y int')
#  exp(2, '(vector2 1 2).y', 'struct vector2:\n  x int\n  y int')
#
#  // algebraic data type
#  exp({__tag: 'a', __value: 1}, 'ab.a 1', 'adt ab:\n  a int\n  b string')
#  exp(1, 'match (ab.a 1):\n  a v: v\n  b s: s.size', 'adt ab:\n  a int\n  b string')
#  exp(2, 'match (ab.b "hi"):\n  a v: v\n  b s: s.size', 'adt ab:\n  a int\n  b string')
#
#  // exp
#  exp(3, '1 + 2')
#  exp(7, '1 + 2 * 3')
#  exp(5, '1 * 2 + 3')
#  exp(true, '([1 2].size == 1 + 1) && [3 4].size == 2')
#  exp(1, '\n  var n 0\n  n = 1\n  n')
#  exp(true, '(s 1) == (s 1)', 'struct s: value int')
#
#  // variable
#  exp(3, '\n  var a 1\n  a += 2\n  a')
#  exp(3, '\n  var a 1\n  def inc: a += 1\n  inc()\n  inc()\n  a')
#
#  // constant
#  exp(2, '\n  let a inc 1\n  a', 'def inc a: a + 1')
#  exp(2, '\n  let a:\n    var b 1\n    b += 1\n    b\n  a')
#
#  // branch
#  exp(1, '\n  if true: return 1\n  2')
#  exp(2, '\n  if false: return 1\n  2')
#  exp(1, 'case true 1 2')
#  exp(2, 'case false 1 2')
#  exp(2, 'case (true && (1 == 2)) 1 2')
#  exp('one', 'switch 1:\n  1: "one"\n  2: "two"')
#
#  // error handling
#  exp('Zero division error', '\n  1/0\n  1')
#  exp('error', '\n  fail "error"\n  1')
#  exp(1, 'catch(1 _ => 2)')
#  exp(2, 'catch((fail "error") e => 2)')
#
#  // do block
#  exp(1, 'do 1')
#  exp(5, 'do 1 (2 + 3)')
#
#  // comments
#  exp(1, '1', '# this is a comment')
#  exp(1, '#comment 1\n  1 # comment 2\n# comment 3', '# this is a comment')
#
#  // bug fixes
#  exp('"', '`"`')
#  exp('\n', '`\n`')
#  exp('\\n', '`\\n`')
#  exp('a"b', '"""a"b"""')
#  exp('a`b', '```a`b```')
#  exp(1, 'f()', 'def f:\n  let a 1\n\n  a')
#  exp('# comment', '"# comment"', )
#  exp(1, '1', '# comment 1', '# comment 2')
#  exp(1, 'case(true\n1\n2)')
#  exp('ell', '"hello".slice 1 (-1)')
#  exp(2, 'case(true 1 2) + 1')
