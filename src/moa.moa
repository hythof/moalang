help = "Moa is a tool for managing Moa source code.

Usage:
  moa <command> [arguments]

The commands are:
  moa                # launch repl
  moa build          # compile to an executable file without test
  moa format file    # format a file
  moa help [topic]   # for more info about topic
  moa js file        # compile to JavaScript
  moa lint file      # report likely mistakes
  moa run [exp]      # run Moa program
  moa test [regexps] # run tests
  moa version        # print Moa version"

main io =
  match io.argv:
    []: repl io
    ["build"]      : io.puts "Not implemented yet"
    ["format" file]: io.puts "Not implemented yet"
    ["help" topic] : io.puts "Not implemented yet"
    ["js" file]    : io.puts "Not implemented yet"
    ["lint" file]  : io.puts "Not implemented yet"
    ["run"]        : io.puts "Not implemented yet"
    ["run" exp]    : io.puts "Not implemented yet"
    ["test"]       : io.puts "Not implemented yet"
    ["test" target]: io.puts "Not implemented yet"
    ["version"]    : io.puts "moa v0.1"
    _              : io.puts help

repl io = io.puts "repl"

compile_to_js source =
  nodes = parse source
  log nodes
  "const main = io => log(io)"

class token:
  label string
  line int
  column int

union type:
  tundef # no type determined yet
  tnil   # for tag only union and field less struct
  tbool
  tint
  tfloat
  tstring
  tlambda list[type]
  tset type
  tlist type
  tdict type type
  ttype list[tuple[string type]]

union ast:
  adefine:
    id string
    desc ast
  abool bool
  aint int
  afloat float
  astring string
  atuple list[ast]
  astatement list[ast]
  alambda:
    args list[string]
    body ast
    type type
  aref:
    id string
    type type
  acall:
    head ast
    argv list[ast]
  aundef string

parse source =
  # list[string]
  tokens =
    trim a = iif:
      a.size == 0: []
      a[0].match("^[ \r\n\t]"): trim a.slice 1
      a[-1].match("^[ \r\n\t]"): trim a.slice 0 -1
      _: a
    regexp = r"""((?:!=)|[()\[\]{}!]|(?:-?[0-9]+(?:\.[0-9]+)?)|[ \t\r\n]+(?:#[^\n]*|[ \t\r\n]+)*|"(?:[^"]|\\")*(?<!\\)"|[A-Za-z0-9_]+|#[^\n]*)"""
    source.rsplit(regexp).keep(t => t.size > 0 && !t.starts("#"))
  pos = 0
  top = () =>
    until end =
      f a = match bottom():
        x.aundef: iif x == end a f(a ++ x)
        x: f a ++ x
      f []
    bottom = () =>
      g = () =>
        pos += 1
        bottom()
      f = () =>
        iif (tokens[pos]).match("^[ \t]+$") g() consume()
      iif pos < tokens.size f() p("")
    consume = () =>
      t = tokens[pos]
      pos += 1
      iif:
        t == "true": abool true
        t == "false": abool false
        t == "[": acall aref("list") until("]")
        t.match "^[0-9.]+\.[0-9]+$": afloat t.float
        t.match "^[0-9]+": aint t.int
        t.starts "\"\"\"": astring t.slice(3 -3).replace("\\t", "\t").replace("\\n", "\n").replace("\\\"", "\"")
        t.starts "\"": astring t.slice(1 -1).replace("\\t", "\t").replace("\\n", "\n").replace("\\\"", "\"")
        t.starts "[": alist [] # TODO
        t.starts "[": adict [] # TODO
        t.match "^[a-zA-Z_]": aref t
        _: aundef t
    #exp = () =>
      #adefine:
      #  id string
      #  desc ast
      #alambda:
      #  args list[string]
      #  body ast
      #  type type
      #aref:
      #  id string
      #  type type
      #acall:
      #  head ast
      #  argv list[ast]
    bottom()
  top()

test t "parser":
  simplify a =
    call x = "(" + ([x.head] ++ x.argv).map(simplify).join(" ") ++ ")"
    match a:
      x.adefine   : x.id ++ " = " ++ simplify(x.desc)
      x.ablool    : string x
      x.aint      : string x
      x.afloat    : string x
      x.astring   : x
      x.astatement: x.map(simplify).join("\n")
      x.alambda   : x.args.join(",") ++ " => " ++ simplify(x.body)
      x.aref      : x.id
      x.acall     : call x
      x.aundef    : x
      x           : log(a)
  t1 expectation ast = t.eq expectation simplify(ast)
  t1 "a = 1" adefine("a" aint(1))
  t1 "1" aint(1)
  t1 "1.1" afloat(1.1)
  t1 "hi" astring("hi")
  t1 "1\n2" astatement([aint(1) aint(2)])
  t1 "a,b => 1" alambda(["a" "b"] aint(1))
  t1 "a" aref("a")

  test expectation source = t.eq expectation simplify(parse(source))

  # primitives
  test "1" "1"
  test "1.1" "1.1"
  test "id" "id"
  test "hi" "\"hi\""
  test "\t" "\"\\t\""
  test "hi" """"hi"""" # "
  test "\t" """"\\t"""" # "
  test "(list)" "[]"
  test "(list 1 2)" "[1 2]"

# bug fix for a[x].f()
# bug fix for () => ...

##  test "(__call dict)" "[:]"
##  test "(dict \"a\" 1)" "[a:1]"
##  test "(dict \"a\" (+ 1 2))" "[a:(1+2)]"
##  test "(dict (+ 1 2) (+ 3 4))" "[(1+2):(3+4)]"
##  test "(dict \"a\" 1 \"b\" (+ 1 2) c (+ 3 4))" "[a:1 b:(1+2) (c):(3+4)]"
##  test "(__call class)" "{}"
##  test "(class a 1)" "{a=1}"
##  test "(class a a b b c (+ 1 2) d 3)" "{a b c=(1+2) d=3}"
##  test "(=> a a)" "a => a"
##  test "(=> (, a b) a)" "a,b => a"
##  test "(=> p (+ 1 2))" "p => 1 + 2"
##  test "(. int)" ".int"
##  test "(f (. int))" "f .int"
##
##  # definition
##  test "(= a 1)" "a = 1"
##  test "(= (f a) a)" "f a = a"
##  test "(= (f a) (__pack (= b 1) (+ a b)))" "f a =\n  b = 1\n  a + b"
##
##  # property access
##  test "(. a b)" "a.b"
##  test "((. a b) c)" "a.b c"
##  test "(. (__call list) length)" "[].length"
##  test "(=> p (+ (. p x) (. p y)))" "p => p.x + p.y"
##
##  # single operator
##  test "(! true)" "!true"
##
##  # binary operators
##  test "(+ 1 2)" "1 + 2"
##  test "(+ (+ 1 2) 3)" "1 + 2 + 3"
##  test "(!= 1 1)" "1 != 1"
##  test "(= a 1)" "a = 1"
##  test "(+= a 1)" "a += 1"
##  test "(= a (+ 1 2))" "a = 1 + 2"
##  test "(+= a (+ 1 2))" "a += 1 + 2"
##  test "(+ 1 (* 2 3))" "1 + 2 * 3"
##  test "(+ 1 (/ 2 3))" "1 + 2 / 3"
##  test "(+ 1 (% 2 3))" "1 + 2 % 3"
##  test "(+ 1 (// 2 3))" "1 + 2 // 3"
##
##  # parentheses
##  test "1" "(1)"
##  test "(f 1)" "(f 1)"
##  test "(+ 1 2)" "(1 + 2)"
##  test "(+ 1 (+ 2 3))" "1 + (2 + 3)"
##
##  # fu ction call
##  test "(__call f)" "f()"
##  test "(f 1)" "f(1)"
##  test "(f (+ 1 2))" "f(1 + 2)"
##
##  # method call
##  test "(. f m)" "f.m"
##  test "(. f 1)" "f.1"
##  test "(__call (. f m))" "f.m()"
##  test "((. f m) a)" "f.m(a)"
##  test "((. f m) a b)" "f.m(a b)"
##
##  # index access
##  test "(__index x 1)" "x[1]"
##  test "(__index x 1 2)" "x[1 2]"
##
##  # steps
##  test "(__pack a b)" "a\nb"
##  test "(__pack (a b) c)" "a b\nc"
##  test "(__pack a (b c))" "a\nb c"
##
##  # block
##  test "(: a b)" "a: b"
##  test "(: (a b) c)" "a b: c"
##  test "(: (a b) (c d))" "a b: c d"
##
##  # indent
##  test "(: a b)" "a:\n  b"
##  test "(: a (: b c))" "a:\n  b:\n    c"
##  test "(: a (: b (__pack c d)))" "a:\n  b:\n    c\n    d"
##  test "(: a (__pack (: b c) d))" "a:\n  b:\n    c\n  d"
##  test "(__pack (: a (: b c)) d)" "a:\n  b:\n    c\nd"
##  test "(__pack (: a (__pack b (: c d) e)) f)" "a:\n  b\n  c:\n    d\n  e\nf"
##
##  # combinations
##  test "(! (a b))" "!a(b)"
##  test "(+ (a b) c)" "a(b) + c"
##
##  # edge case
##  test "1" "1\n"
##  test "()" "n"
##  test "()" "\n"
