# data type
token:
  tag string
  code string
ast|
  aint: value token
  astr: value token
  aid: name token
  apair: value token
  alist: values [token]
  afunc: name token, args [token], body ast
  acall: target ast, argv [token]
  aop2: op token, lhs ast, rhs ast
  atype: name token, targs [token], members [token token]

# helper
many_acc f acc = f.then(c => many_acc(f acc.concat([c]))).alt(acc)
many f = many_acc(f [])
many1 f =
  c <- f
  cs <- many(f)
  [c].concat(cs)

# main process
op2s = "&& || == != => <= < >= > = + - * / % .".split(" ")
syms = "= : ( ) [ ]".split(" ").concat(op2s)
tokenize src =
  pos := 0
  equal s =
    ss <- src.slice(pos pos+s.count)
    #__dump(["equal" src (ss==s) pos s ss])
    guard(ss == s)
    pos += s.count
    s
  satisfy f =
    c <- src.at(pos)
    #__dump(["satisfy" src f(c) pos c])
    guard(f(c))
    pos += 1
    c
  read_chars n =
    satisfy(c => (c == n.char))
    cs <- many(satisfy(c => c != n.char))
    satisfy(c => (c == n.char))
    token("str" cs.join(""))
  not_chars s =
    many(satisfy(c => (c != s)))
  many1t tag f = many1(f).then(cs => token(tag cs.join("")))
  read_int = many1t("int" satisfy(c => ("0" <= c) && (c <= "9")))
  read_id = many1t("id" satisfy(c => ("a" <= c) && (c <= "z")))
  read_str = read_chars(34).alt(read_chars(96))
  read_spaces = many1t("spaces" satisfy(c => " \n#".includes(c)))
  read_sym =
    syms.first(equal).then(s => token("sym" s))
  read_top = read_id.alt(read_int read_str read_spaces read_sym)
  tokens <- many(read_top)
  assert(pos == src.count)
  tokens.filter(t => t.tag != "spaces")
parse tokens =
  pos := 0
  consume f =
    t <- tokens.at(pos)
    guard(f(t))
    pos += 1
    t
  look =
    tokens.at(pos).alt(token("eot" ""))
  consume_id =
    consume(t => t.tag == "id")
  consume_code s =
    consume(t => t.code == s)
  consume_between l r c =
    consume_code(l)
    ret <- c
    consume_code(r)
    ret
  parse_define =
    name <- consume_id
    args <- many(consume_id)
    mark <- consume(t => ["=" ":"].includes(t.code))
    read_struct =
      atype(name args [])
    match(mark.code
      "=" parse_exp.then(body => afunc(name args body))
      ":" read_struct)
  parse_unit =
    parse_parenthesis =
      consume_between("(" ")" parse_exp).then(apair)
    parse_list =
      consume_between("[" "]" many(parse_exp)).then(alist)
    parse_int =
      consume(t => t.tag == "int").then(aint)
    parse_str =
      consume(t => t.tag == "str").then(astr)
    parse_id =
      consume(t => t.tag == "id").then(aid)
    parse_call target =
      consume_code("(")
      argv <- many(parse_exp)
      consume_code(")")
      acall(target argv)
    val <- parse_parenthesis.alt(parse_list parse_int parse_str parse_id)
    parse_call(val).alt(val)
  parse_exp =
    token <- parse_unit
    parse_op2 =
      op <- consume(t => op2s.includes(t.code))
      rhs <- parse_exp
      aop2(op token rhs)
    parse_op2.alt(token)

  defines <- many(parse_define)
  assert(tokens.count == pos tokens.at(pos))
  defines
generate defines =
  call args = if(args.present "(" + args.map(a=>a.code).join(",") + ")=>" "")
  keys xs = xs.map(x => x.at(0).code).join(",")
  wrap a = match(a
    aint "(" + gen(a) + ")"
    _ gen(a))
  gen a = match(a
    aint  a.value.code
    astr  a.value.code.string
    aid   a.name.code
    apair ("(" + gen(a.value) + ")")
    atype ("const " + a.name.code + " = (" + keys(a.members) + ")" + " => ({" + keys(a.members) + "})")
    alist ("[" + a.values.map(gen).join(",") + "]")
    afunc ("const " + a.name.code + " = " + call(a.args) + gen(a.body))
    acall (gen(a.target) + "(" + a.argv.map(gen).join(",") + ")")
    aop2  (wrap(a.lhs) + a.op.code + gen(a.rhs)))
  defines.map(gen).join("\n")
compile src =
  tokens <- tokenize(src)
  defines <- parse(tokens)
  js <- generate(defines)
  #__dump([js defines])
  js
