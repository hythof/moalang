compile src =
  tokens <- tokenize(src)
  defines <- parse(tokens)
  generate(defines)

pos:
  line int
  column int

token|
  share(string pos)
  int
  bool
  string
  id
  symbol
  indent
  br

type|
  any
  int
  string
  bool
  array type
  user:
    name string
    generics []type

node|
  share(type pos)
  int int
  string string
  bool bool
  array []node
  stmt []node
  ref string
  op2:
    op string
    left node
    right node
  lambda:
    name string
    args []string
    body node
  call:
    self node
    args []node
  struct:
    name string
    generics []string
    fields []define
  enum:
    name string
    generics []string
    tags []define

inference []string,node node opt(node)
inference scope node = ask(node):
  ask node =
  | .int = node(.type = .int)
  | .string = node(type: .string)
  | .stmt = node.last.then(ask)
  | .op2 = ask(node.left)
  | .lambda = ask(node.body)
  | .ref = find(node.name)
  | .method = ask(self)
  | .struct = node(type: .user(node.name node.generics))
  | .enum = node(type: .user(node.name node.generics))
  | type.any
  user name generics =
    types <- generics.map(find)
    type.user(name types)
  find name = scope.find(_ s = s.name == name).then(ask).fail("not found $name")

define:
  name string
  node node

mark = ": |".split(" ")
op2 = "+ - * / > >= < <= == != || && := <-".split(" ")
op2u = ":= <-".split(" ")

tokenize src = top:
  pos 0
  top =
    tokens <- many1([t_br t_indent t_int t_bool t_string t_id t_symbol].first)
    assert(pos == src.size)
    tokens.append(token.br)
  t_br = many1(line).and(token.br)
  t_indent = many1(eq("  ")).then(token.indent)
  t_int = many1(any("0123456789".array)).then(token.int)
  t_bool = many1(any(["true" "false"])).then(_ s = token.bool(s))
  t_string = between(eq("\"") eq("\"") many(satisfy(_ c = c != "\"").then(token.string)))
  t_id = many1(any("abcdefghijklmnopqrstuvwxyz_[]".array)).then(token.id)
  t_symbol = many1(any(mark ++ op2 ++ op2u)).then(token.symbol)
  line = many(eq(" ")).then(any("\r\n".array)
  any ary = ary.first(eq)
  eq s = (src.slice(pos -1) == s).then(go):
    go =
      pos += s.size
      s

parse tokens = top:
  pos 0
  top =
    defines <- many1(p_define)
    assert(pos == tokens.size)
    defines
  p_define =
    name <- take(.id)
    args <- many(take(.id))
    symbol <- take(.symbol)
    symbol
    | "=" -> p_body.then(_ body = define(name node.lambda(args body)))
    | ":" -> p_fields.then(_ fields = define(name node.struct(name args fields)))
  p_body = p_stmt.or(p_exp)
    p_stmt = many1(p_line):
      p_line =
        take(.indent)
        exp <- p_exp
        take(.br)
        exp
    p_exp = p_group.or(p_op2.or(p_unit)):
      p_group = between(eq("(") eq(")") p_exp)
      p_op2 =
        l <- p_exp
        p_remain(l).or(l)
      p_remain l =
        o <- select(op2)
        r <- p_exp
        p_remain(node.op2(o l r))
  p_fields = many1(p_field):
    p_field =
      take(.indent)
      id <- take(.id)
      type <- take(.id)
      take(.br)
      define(id type)
  take expect = expect.instance_of(t).then(t)
  select ary = ary.first(eq)
  eq s = t:
    | .int = pos+=1; s
    | .bool = pos+=1; s
    | .string = pos+=1; s
    | .id = pos+=1; s
    | .symbol = pos+=1; s
    | nil
  t = tokens.at(pos)


generate defines = ...

- private
many1 f =
  c <- f
  cs <- many(f)
  cs.prepend(c)
many f = r().or(acc.reverse):
  acc []
  r =
    v <- f
    acc.push(v)
between l r m =
  l
  v <- m
  r
  v
