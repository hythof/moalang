struct Token:
  code string
  line int
  column int

struct Tree:
  leaf Token
  forest []Tree

def tokenize src:
  var tokens []
  var line 1
  var column 1
  let id "abcdefghijklmnopqrstuvxwyz_"
  let num "0123456789"
  let idnum id + num
  let singles "():."
  let symbols "+ - * / = :".split " "

  def push fragment:
    tokens.push Token(fragment line column)
    column += fragment.replace("\n" "").size

  def quote q:
    i += 1
    push q + until(c => c != q) + q
    i += 1

  def until f:
    s = ""
    while i < src.size && f(src.at(i)):
      s += src.at i
      i += 1
    i -= 1
    s

  def br:
    s = ""
    while i < src.size && src.at(i) == "\n":
      i += 1
      line += 1
      s = "\n" + until(c => c == " ")
    column = 1
    push s

  var i 0
  while i < src.size:
    var c src.at i
    if c == "\\":
      i += 1
      c = src.at i
      fork:
        c == "n": c = "\n"
        c == "t": c = "\t"
        c == "\\": c = "\\"
    fork:
      c == `"`: quote c
      c == `'`: quote c
      c == " ": column += until(c => c == " ").size
      c == "\n": br
      singles.contains c: push c
      symbols.contains c: push until(symbols.contains)
      id.contains c: push until(idnum.contains)
      num.contains c: push until(num.contains)
    i += 1
  tokens

def parse tokens:
  io.print tokens.size
  []

def generate nodes:
  "hi!"

def main:
  let src io.stdin
  let tokens tokenize src
  let nodes parse tokens
  let js generate nodes
  io.print "-- nodes:"
  io.dump nodes

test t:
  t.eq [Token("def" 1 1) Token("f" 1 5) Token(":" 1 6) Token("\n  " 2 1) Token("1" 2 3)] tokenize(`def f:\n  1`)
  t.eq ["def" "func" "arg1" ":" "\n  " "f" "(" "arg1" "+" "10" ")" "==" `"hi"` "." "size"] tokenize(`def func arg1:\n  f (arg1 + 10) == "hi".size`).map(t => t.code)
