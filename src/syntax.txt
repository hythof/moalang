# Syntax for moa
top: exp+
exp: atom (op2 exp)*
atom:
| ":" block
| "=>" block
| value suffix*
suffix:
| "(" top ")"
| "." id
value:
| id
| num ("." num)?
| "(" top ")"
| "[" top? "]"  # array
| '"' [^"]* '"' # string
| "`" [^`]* "`" # dynamic string
block:
| (indent top)+
| exp

id: [A-Za-z_][A-Za-z0-9_]
num: [0-9]+
op2: + - * / // % = += -= *= /= == != || && >= > <= < ->
indent: "\n" " "+

# Minimul requirements?
- int             : 1
- string          : "hi"
- lambda          : a => a
- apply           : f(a)
- define          : n = 1
- binary operator : (1 + 2) * 3
- branch          : if(false 1 true 2 3)
- loop            : sum = until(f -> if(a < 0
- array           : [1 2]
- error handling  : e = error(reason: string), try(fail(error("eof")) e -> e.reason)
- type annotation : (a:int b:int :int) => a + b
- variable        : a:int:ref

# Nice to have?
- Type inference
- Hash table
