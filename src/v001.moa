compile src = do(
  tokens <- tokenize(src)
  defines <- parse(tokens)
  generate(defines))

define: struct(name:string node:node)

token: enum(
  int:string
  bool:string
  string:string
  id:string
  symbol:string)

node: enum(
  int:int
  string:string
  bool:bool
  id:string
  list:string
  struct:list(define)
  enum:list(define)
  lambda:struct(
    name:string
    args:list(string)
    body:node)
  op2:struct(
    op:string
    left:node
    right:node)
  call: struct(
    self:node
    args:list(node)))

mark = ": |".split(" ")
op2 = "+ - * / > >= < <= == != || && := <-".split(" ")
op2u = ":= <-".split(" ")

tokenize src = do(
  pos <- var(0)
  top
  top = many1(list(t_br t_indent t_int t_bool t_string t_id t_symbol).first)
  t_int = many1(some("0123456789".array)).then(token.int)
  t_bool = many1(some(["true" "false"])).then(_ s = token.bool(s))
  t_string = between(eq("\"") eq("\"") many(satisfy(_ c = c != "\"").then(token.string)))
  t_id = many1(some("abcdefghijklmnopqrstuvwxyz_[]".array)).then(token.id)
  t_symbol = many1(some(mark ++ op2 ++ op2u)).then(token.symbol)
  some ary = ary.first(eq)
  eq s = (src.slice(pos - 1) == s).then(do(pos+=s.size s)))

parse tokens = top:
  pos 0
  top =
    defines <- many1(p_define)
    assert(pos == tokens.size)
    defines
  p_define =
    name <- take(.id)
    args <- many(take(.id))
    symbol <- take(.symbol)
    symbol
    | "=" -> p_body.then(_ body = define(name node.lambda(args body)))
    | ":" -> p_fields.then(_ fields = define(name node.struct(name args fields)))
  p_body = p_stmt.or(p_exp)
    p_stmt = many1(p_line):
      p_line =
        take(.indent)
        exp <- p_exp
        take(.br)
        exp
    p_exp = p_group.or(p_op2.or(p_unit)):
      p_group = between(eq("(") eq(")") p_exp)
      p_op2 =
        l <- p_exp
        p_remain(l).or(l)
      p_remain l =
        o <- select(op2)
        r <- p_exp
        p_remain(node.op2(o l r))
  p_fields = many1(p_field):
    p_field =
      take(.indent)
      id <- take(.id)
      type <- take(.id)
      take(.br)
      define(id type)
  take expect = expect.instance_of(t).then(t)
  select ary = ary.first(eq)
  eq s = t:
    | .int = pos+=1; s
    | .bool = pos+=1; s
    | .string = pos+=1; s
    | .id = pos+=1; s
    | .symbol = pos+=1; s
    | nil
  t = tokens.at(pos)


generate defines = ...

# private
many1 f =
  c <- f
  cs <- many(f)
  cs.prepend(c)
many f = r().or(acc.reverse):
  acc []
  r =
    v <- f
    acc.push(v)
between l r m =
  l
  v <- m
  r
  v
